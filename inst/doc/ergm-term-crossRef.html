<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="statnet.org" />

<meta name="date" content="2014-07-28" />

<title>ERGM terms cross-reference</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">ERGM terms cross-reference</h1>
<h4 class="author">statnet.org</h4>
<h4 class="date">07/28/2014</h4>



<style type="text/css">
table, td, th {
  border: 1px solid #cccccc;
  padding: 8px;
}
</style>
<p>This document is an automatically generated cross reference for the ergm model terms from the <a href="https://statnet.org">stanet project</a>. The source for this data and additional descriptions are in the <code>?ergm.terms</code> help file or the <a href="https://cran.r-project.org/package=ergm">ergm manual</a>.</p>
<div id="interactive-searching" class="section level2">
<h2>Interactive searching</h2>
<p>It is possible to search the <code>ergm-terms</code> help page and search for specific categories of terms using the <code>search.ergmTerms</code> command. For example to find all the terms that mention ‘triangle’ in their description:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">search.ergmTerms</span>(<span class="dt">keyword=</span><span class="st">&#39;triangle&#39;</span>)</span></code></pre></div>
<pre><code>## Found  10  matching ergm terms:
## Symmetrize(formula, rule=&quot;weak&quot;)
##  Evaluation on symmetrized (undirected) networ
## 
## ctriple(attr=NULL, diff=FALSE, levels=NULL)
##  Cyclic triples
## 
## ctriad()
##  Cyclic triples
## 
## localtriangle(x)
##  Triangles within neighborhoods
## 
## opentriad()
##  Open triads
## 
## threetrail(keep=NULL, levels=NULL)
##  Three-trails
## 
## triangle(attr=NULL, diff=FALSE, levels=NULL)
##  Triangles
## 
## tripercent(attr=NULL, diff=FALSE, levels=NULL)
##  Triangle percentage
## 
## ttriple(attr=NULL, diff=FALSE, levels=NULL)
##  Transitive triples
## 
## ttriad()
##  Transitive triples</code></pre>
<p>Or to find all of the dyad-independent bipartite terms:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">search.ergmTerms</span>(<span class="dt">categories=</span><span class="kw">c</span>(<span class="st">&#39;bipartite&#39;</span>,<span class="st">&#39;dyad-independent&#39;</span>))</span></code></pre></div>
<pre><code>## Found  15  matching ergm terms:
## b1cov(attr)
##  Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
## 
## b1cov(attr, form=&quot;sum&quot;)
##  Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
## 
## b1factor(attr, base=1, levels=-1)
##  Factor attribute effect for the first mode in a bipartite (aka two-mode) network
## 
## b1factor(attr, base=1, levels=-1, form=&quot;sum&quot;)
##  Factor attribute effect for the first mode in a bipartite (aka two-mode) network
## 
## b1nodematch(attr, diff=FALSE, keep=NULL, alpha=1, beta=1,)
##  Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network
## 
## b1sociality(nodes=-1)
##  Degree
## 
## b1sociality(nodes=-1, form=&quot;sum&quot;)
##  Degree
## 
## b2cov(attr)
##  Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
## 
## b2cov(attr, form=&quot;sum&quot;)
##  Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
## 
## b2factor(attr, base=1, levels=-1)
##  Factor attribute effect for the second mode in a bipartite (aka two-mode) network 
## 
## b2factor(attr, base=1, levels=-1, form=&quot;sum&quot;)
##  Factor attribute effect for the second mode in a bipartite (aka two-mode) network 
## 
## b2nodematch(attr, diff=FALSE, keep=NULL, alpha=1, beta=1,)
##  Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network
## 
## b2sociality(nodes=-1)
##  Degree
## 
## b2sociality(nodes=-1, form=&quot;sum&quot;)
##  Degree
## 
## diff(attr, pow=1, dir=&quot;t-h&quot;, sign.action=&quot;identity&quot;, form =&quot;sum&quot;)
##  Difference</code></pre>
</div>
<div id="basic-frequently-used-term-category-matrix" class="section level2">
<h2>Basic / Frequently-used term category matrix</h2>
<p>For convenience, this table lists a subset of the most commonly-used ergm terms and categories.</p>
<table>
<tr>
<th>
Term name
</th>
<th>
binary
</th>
<th>
valued
</th>
<th>
directed
</th>
<th>
undirected
</th>
<th>
bipartite
</th>
<th>
dyad-independent
</th>
<th>
operator
</th>
<th>
layer-aware
</th>
</tr>
<tr>
<td align="center">
<a href="#term_absdiff_1">absdiff</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1cov_1">b1cov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1cov_2">b1cov</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1degree_1">b1degree</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1factor_1">b1factor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1factor_2">b1factor</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1nodematch_1">b1nodematch</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2concurrent_1">b2concurrent</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2cov_1">b2cov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2cov_2">b2cov</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2degree_1">b2degree</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2factor_1">b2factor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2factor_2">b2factor</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2nodematch_1">b2nodematch</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_degree_1">degree</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_diff_1">diff</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_edgecov_1">edgecov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_edges_1">edges</a>
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwdegree_1">gwdegree</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwesp_1">gwesp</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_idegree_1">idegree</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_isolates_1">isolates</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_mm_1">mm</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_mm_2">mm</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_mutual_1">mutual</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodecov_1">nodecov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodefactor_1">nodefactor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeicov_1">nodeicov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeifactor_1">nodeifactor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodematch_1">nodematch</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodemix_1">nodemix</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_odegree_1">odegree</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_triangle_1">triangle</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
</table>
<p>For convenience, this table lists operator terms: terms that wrap or modify other terms.</p>
<table>
<tr>
<th>
Term name
</th>
<th>
binary
</th>
<th>
valued
</th>
<th>
directed
</th>
<th>
undirected
</th>
<th>
bipartite
</th>
<th>
dyad-independent
</th>
<th>
operator
</th>
<th>
layer-aware
</th>
</tr>
<tr>
<td align="center">
<a href="#term_B_1">B</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Parametrize_1">Parametrize</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Parametrise_2">Parametrise</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Curve_3">Curve</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Parametrize_4">Parametrize</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Parametrise_5">Parametrise</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Curve_6">Curve</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Exp_1">Exp</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Exp_2">Exp</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_F_1">F</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Log_1">Log</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Log_2">Log</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Prod_1">Prod</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Prod_2">Prod</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_S_1">S</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Sum_1">Sum</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Sum_2">Sum</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Symmetrize_1">Symmetrize</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Label_1">Label</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Label_2">Label</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_NodematchFilter_1">NodematchFilter</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Offset_1">Offset</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
</table>
</div>
<div id="complete-term-category-matrix" class="section level2">
<h2>Complete term category matrix</h2>
<p>This table lists the complete set of terms available in the ergm package. In HTML versions, clicking on a term name will jump to its definition.</p>
<table>
<tr>
<th>
Term name
</th>
<th>
valued
</th>
<th>
operator
</th>
<th>
binary
</th>
<th>
directed
</th>
<th>
dyad-independent
</th>
<th>
frequently-used
</th>
<th>
undirected
</th>
<th>
quantitative nodal attribute
</th>
<th>
categorical nodal attribute
</th>
<th>
curved
</th>
<th>
triad-related
</th>
<th>
bipartite
</th>
<th>
deprecated
</th>
<th>
non-negative
</th>
</tr>
<tr>
<td align="center">
<a href="#term_B_1">B</a>
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Parametrize_1">Parametrize</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Parametrise_2">Parametrise</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Curve_3">Curve</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Parametrize_4">Parametrize</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Parametrise_5">Parametrise</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Curve_6">Curve</a>
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Exp_1">Exp</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Exp_2">Exp</a>
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_F_1">F</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Log_1">Log</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Log_2">Log</a>
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Prod_1">Prod</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Prod_2">Prod</a>
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_S_1">S</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Sum_1">Sum</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Sum_2">Sum</a>
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Symmetrize_1">Symmetrize</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Label_1">Label</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Label_2">Label</a>
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_NodematchFilter_1">NodematchFilter</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_Offset_1">Offset</a>
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_absdiff_1">absdiff</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_absdiff_2">absdiff</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_absdiffcat_1">absdiffcat</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_absdiffcat_2">absdiffcat</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_altkstar_1">altkstar</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_asymmetric_1">asymmetric</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_atleast_1">atleast</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_atmost_1">atmost</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_attrcov_1">attrcov</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1concurrent_1">b1concurrent</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1cov_1">b1cov</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1cov_2">b1cov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1degrange_1">b1degrange</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1degree_1">b1degree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1dsp_1">b1dsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1factor_1">b1factor</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1factor_2">b1factor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1mindegree_1">b1mindegree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1nodematch_1">b1nodematch</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1sociality_1">b1sociality</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1sociality_2">b1sociality</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1star_1">b1star</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1starmix_1">b1starmix</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b1twostar_1">b1twostar</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2concurrent_1">b2concurrent</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2cov_1">b2cov</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2cov_2">b2cov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2degrange_1">b2degrange</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2degree_1">b2degree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2dsp_1">b2dsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2factor_1">b2factor</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2factor_2">b2factor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2mindegree_1">b2mindegree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2nodematch_1">b2nodematch</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2sociality_1">b2sociality</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2sociality_2">b2sociality</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2star_1">b2star</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2starmix_1">b2starmix</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_b2twostar_1">b2twostar</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_balance_1">balance</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_coincidence_1">coincidence</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_concurrent_1">concurrent</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_concurrentties_1">concurrentties</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_ctriple_1">ctriple</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_ctriad_2">ctriad</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_cycle_1">cycle</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_cyclicalties_1">cyclicalties</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_cyclicalties_2">cyclicalties</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_cyclicalweights_1">cyclicalweights</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_ddsp_1">ddsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_degrange_1">degrange</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_degree_1">degree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_degree1.5_1">degree1.5</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_degreepopularity_1">degreepopularity</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_degcrossprod_1">degcrossprod</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_degcor_1">degcor</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_density_1">density</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_diff_1">diff</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_diff_2">diff</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_desp_1">desp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_dgwdsp_1">dgwdsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_dgwesp_1">dgwesp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_dgwnsp_1">dgwnsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_dnsp_1">dnsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_dsp_1">dsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_dyadcov_1">dyadcov</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_edgecov_1">edgecov</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_edgecov_2">edgecov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_edges_1">edges</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nonzero_2">nonzero</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_esp_1">esp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_equalto_1">equalto</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_greaterthan_1">greaterthan</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwb1degree_1">gwb1degree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwb1dsp_1">gwb1dsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwb2degree_1">gwb2degree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwb2dsp_1">gwb2dsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwdegree_1">gwdegree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwdsp_1">gwdsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwesp_1">gwesp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwidegree_1">gwidegree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwnsp_1">gwnsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_gwodegree_1">gwodegree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_hamming_1">hamming</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_idegrange_1">idegrange</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_idegree_1">idegree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_idegree1.5_1">idegree1.5</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_idegreepopularity_1">idegreepopularity</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_ininterval_1">ininterval</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_intransitive_1">intransitive</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_intransitive_1">intransitive</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_isolatededges_1">isolatededges</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_isolates_1">isolates</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_istar_1">istar</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_kstar_1">kstar</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_smallerthan_1">smallerthan</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_localtriangle_1">localtriangle</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_m2star_1">m2star</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_meandeg_1">meandeg</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_mm_1">mm</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_mm_2">mm</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_mutual_1">mutual</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_mutual_2">mutual</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nearsimmelian_1">nearsimmelian</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodecov_1">nodecov</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodecov_2">nodecov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodemain_3">nodemain</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodecovar_1">nodecovar</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodecovar_1">nodecovar</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodefactor_1">nodefactor</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodefactor_2">nodefactor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeicov_1">nodeicov</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeicov_2">nodeicov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeicovar_1">nodeicovar</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeifactor_1">nodeifactor</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeifactor_2">nodeifactor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodematch_1">nodematch</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodematch_2">nodematch</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_match_3">match</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodemix_1">nodemix</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodemix_2">nodemix</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeocov_1">nodeocov</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeocov_2">nodeocov</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeocovar_1">nodeocovar</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeofactor_1">nodeofactor</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nodeofactor_2">nodeofactor</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_nsp_1">nsp</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_odegrange_1">odegrange</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_odegree_1">odegree</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_odegree1.5_1">odegree1.5</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_odegreepopularity_1">odegreepopularity</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_opentriad_1">opentriad</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_ostar_1">ostar</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_receiver_1">receiver</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_receiver_2">receiver</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_sender_1">sender</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_sender_2">sender</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_simmelian_1">simmelian</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_simmelianties_1">simmelianties</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_smalldiff_1">smalldiff</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_sociality_1">sociality</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_sociality_2">sociality</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_sum_1">sum</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_threetrail_1">threetrail</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_transitive_1">transitive</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_transitiveties_1">transitiveties</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_transitiveties_2">transitiveties</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_transitiveweights_1">transitiveweights</a>
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
</tr>
<tr>
<td align="center">
<a href="#term_triadcensus_1">triadcensus</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_triangle_1">triangle</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_tripercent_1">tripercent</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_ttriple_1">ttriple</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_ttriad_2">ttriad</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
<tr>
<td align="center">
<a href="#term_twopath_1">twopath</a>
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
✔
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
<td align="center">
</td>
</tr>
</table>
</div>
<div id="term-definitions-table" class="section level2">
<h2>Term definitions table</h2>
<p>This table lists full definitions for all of the terms along with their tags. Note that some terms may have multiple versions (e.g. valued vs. binary) with slightly different arguments and will be listed more than once with the same definition.</p>
<table border="1" cellpadding="8">
<tr>
<blockquote>
<th>
Description
</th>
<th>
Categories
</th>
</tr>
<tr>
<td>
<a id="term_B_1">B(formula, form)</a><br>
<p>
Wraps binary <code>ergm</code> terms for use in valued models, with <code>formula</code> specifying which terms are to be wrapped and <code>form</code> specifying how they are to be used and how the binary network they are evaluated on is to be constructed. More precisely,
</p>
<dl>
<dt>
<code>formula</code>
</dt>
<dd>
<p>
A one-sided formula whose RHS contains the binary <code>ergm</code> terms to be used. Which terms may be used depends on the argument <code>form</code>.
</p>
</dd>
<dt>
<code>form</code>
</dt>
<dd>
<p>
One of three values:
</p>
<dl>
<dt>
<code>“sum”</code>
</dt>
<dd>
<p>
see section “Generalizations of binary terms” above; all terms in <code>formula</code> must be dyad-independent.
</p>
</dd>
<dt>
<code>“nonzero”</code>
</dt>
<dd>
<p>
section “Generalizations of binary terms” above; any binary <code>ergm</code> terms may be used in <code>formula</code>.
</p>
</dd>
<dt>
a one-sided formula
</dt>
<dd>
<p>
value-dependent network. <code>form</code> must contain one <em>valued</em> <code>ergm</code> term, with the following properties:
</p>
<ul>
<li>
<p>
dyadic independence;
</p>
</li>
<li>
<p>
dyadwise contribution of either 0 or 1; and
</p>
</li>
<li>
<p>
dyadwise contribution of 0 for a 0-valued dyad.
</p>
</li>
</ul>
<p>
Formally, this means that it is expressable as
</p>
<p style="text-align: center;">
<i>sum[i,j] f[i,j] (y[i,j]),</i>
</p>
<p>
, where for all <i>i</i>, <i>j</i>, and <i>y</i>, <i>f_{i,j}(y_{i,j})</i> is either 0 or 1 and, in particular, <i>f[i,j] (0)=0</i>.
</p>
<p>
Examples of such terms include <code>nonzero</code>, <code>ininterval()</code>, <code>atleast()</code>, <code>atmost()</code>, <code>greaterthan()</code>, <code>lessthen()</code>, and <code>equalto()</code>.
</p>
<p>
Then, the value of the statistic will be the value of the statistics in <code>formula</code> evaluated on a binary network that is defined to have an edge if and only if the corresponding dyad of the valued network adds 1 to the valued term in <code>form</code>.
</p>
</dd>
</dl>
</dd>
</dl>
<p>
For example, <code>B(~nodecov(“a”), form=“sum”)</code> is equivalent to <code>nodecov(“a”, form=“sum”)</code> and similarly with <code>form=“nonzero”</code>.
</p>
<p>
When a valued implementation is available, it should be preferred, as it is likely to be faster.
</p>
</td>
<td>
valued, operator
</td>
</tr>
<tr>
<td>
<a id="term_Parametrize_1">Parametrize(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf, cov=NULL)</a><br>
<p>
<em>Impose a curved structure on term parameters.</em>
</p>
<p>
<code>formula</code> is an arbitrary formula for a linear or curved ERGM. <code>params</code>, <code>map</code>, <code>gradient</code>, <code>minpar</code>, <code>maxpar</code>, and <code>cov</code> are the curved ERGM term API: a named list whose names are the curved parameter names, the mapping from curved to canonical, its gradient function, the minimum and the maximum allowed curved parameter values, and an optional “covariate” object.
</p>
<p>
Arguments may have the same forms as in the API, but for convenience, alternative forms are accepted.
</p>
<dl>
<dt>
<code>params</code>
</dt>
<dd>
<p>
may also be a character verctor with names.
</p>
</dd>
<dt>
<code>minpar</code> and <code>maxpar</code>
</dt>
<dd>
<p>
will be recycled to appropriate length.
</p>
</dd>
<dt>
<code>map</code>
</dt>
<dd>
<p>
may have the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric vector of length <code>n</code>.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
to fix the output coefficients, like in an offset.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“rep”</code>
</dt>
<dd>
<p>
recycle the input vector to the length of the output vector as a <code>rep</code> function would.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>
<code>gradient</code>
</dt>
<dd>
<p>
is optional if <code>map</code> is constant or one of the predefined forms; otherwise, it must have one of the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric matrix with <code>length(params)</code> rows and <code>n</code> columns.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
to fix the gradient; this is useful when <code>map</code> is linear.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“linear”</code>
</dt>
<dd>
<p>
calculate the (constant) gradient matrix using finite differences. Note that this will be done only once at the initialization stage, so use only if you are certain <code>map</code> is, in fact, linear.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>
If the model in <code>formula</code> is curved, then the outputs of this operator term’s <code>map</code> argument will be used as inputs to the curved terms of the <code>formula</code> model.
</p>
<p>
<code>Curve</code> is an obsolete alias and may be deprecated and removed in a future release.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Parametrise_2">Parametrise(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf, cov=NULL)</a><br>
<p>
<em>Impose a curved structure on term parameters.</em>
</p>
<p>
<code>formula</code> is an arbitrary formula for a linear or curved ERGM. <code>params</code>, <code>map</code>, <code>gradient</code>, <code>minpar</code>, <code>maxpar</code>, and <code>cov</code> are the curved ERGM term API: a named list whose names are the curved parameter names, the mapping from curved to canonical, its gradient function, the minimum and the maximum allowed curved parameter values, and an optional “covariate” object.
</p>
<p>
Arguments may have the same forms as in the API, but for convenience, alternative forms are accepted.
</p>
<dl>
<dt>
<code>params</code>
</dt>
<dd>
<p>
may also be a character verctor with names.
</p>
</dd>
<dt>
<code>minpar</code> and <code>maxpar</code>
</dt>
<dd>
<p>
will be recycled to appropriate length.
</p>
</dd>
<dt>
<code>map</code>
</dt>
<dd>
<p>
may have the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric vector of length <code>n</code>.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
to fix the output coefficients, like in an offset.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“rep”</code>
</dt>
<dd>
<p>
recycle the input vector to the length of the output vector as a <code>rep</code> function would.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>
<code>gradient</code>
</dt>
<dd>
<p>
is optional if <code>map</code> is constant or one of the predefined forms; otherwise, it must have one of the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric matrix with <code>length(params)</code> rows and <code>n</code> columns.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
to fix the gradient; this is useful when <code>map</code> is linear.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“linear”</code>
</dt>
<dd>
<p>
calculate the (constant) gradient matrix using finite differences. Note that this will be done only once at the initialization stage, so use only if you are certain <code>map</code> is, in fact, linear.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>
If the model in <code>formula</code> is curved, then the outputs of this operator term’s <code>map</code> argument will be used as inputs to the curved terms of the <code>formula</code> model.
</p>
<p>
<code>Curve</code> is an obsolete alias and may be deprecated and removed in a future release.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Curve_3">Curve(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf, cov=NULL)</a><br>
<p>
<em>Impose a curved structure on term parameters.</em>
</p>
<p>
<code>formula</code> is an arbitrary formula for a linear or curved ERGM. <code>params</code>, <code>map</code>, <code>gradient</code>, <code>minpar</code>, <code>maxpar</code>, and <code>cov</code> are the curved ERGM term API: a named list whose names are the curved parameter names, the mapping from curved to canonical, its gradient function, the minimum and the maximum allowed curved parameter values, and an optional “covariate” object.
</p>
<p>
Arguments may have the same forms as in the API, but for convenience, alternative forms are accepted.
</p>
<dl>
<dt>
<code>params</code>
</dt>
<dd>
<p>
may also be a character verctor with names.
</p>
</dd>
<dt>
<code>minpar</code> and <code>maxpar</code>
</dt>
<dd>
<p>
will be recycled to appropriate length.
</p>
</dd>
<dt>
<code>map</code>
</dt>
<dd>
<p>
may have the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric vector of length <code>n</code>.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
to fix the output coefficients, like in an offset.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“rep”</code>
</dt>
<dd>
<p>
recycle the input vector to the length of the output vector as a <code>rep</code> function would.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>
<code>gradient</code>
</dt>
<dd>
<p>
is optional if <code>map</code> is constant or one of the predefined forms; otherwise, it must have one of the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric matrix with <code>length(params)</code> rows and <code>n</code> columns.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
to fix the gradient; this is useful when <code>map</code> is linear.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“linear”</code>
</dt>
<dd>
<p>
calculate the (constant) gradient matrix using finite differences. Note that this will be done only once at the initialization stage, so use only if you are certain <code>map</code> is, in fact, linear.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>
If the model in <code>formula</code> is curved, then the outputs of this operator term’s <code>map</code> argument will be used as inputs to the curved terms of the <code>formula</code> model.
</p>
<p>
<code>Curve</code> is an obsolete alias and may be deprecated and removed in a future release.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Parametrize_4">Parametrize(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf, cov=NULL)</a><br>
<p>
<em>Impose a curved structure on term parameters.</em>
</p>
<p>
<code>formula</code> is an arbitrary formula for a linear or curved ERGM. <code>params</code>, <code>map</code>, <code>gradient</code>, <code>minpar</code>, <code>maxpar</code>, and <code>cov</code> are the curved ERGM term API: a named list whose names are the curved parameter names, the mapping from curved to canonical, its gradient function, the minimum and the maximum allowed curved parameter values, and an optional “covariate” object.
</p>
<p>
Arguments may have the same forms as in the API, but for convenience, alternative forms are accepted.
</p>
<dl>
<dt>
<code>params</code>
</dt>
<dd>
<p>
may also be a character verctor with names.
</p>
</dd>
<dt>
<code>minpar</code> and <code>maxpar</code>
</dt>
<dd>
<p>
will be recycled to appropriate length.
</p>
</dd>
<dt>
<code>map</code>
</dt>
<dd>
<p>
may have the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric vector of length <code>n</code>.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
to fix the output coefficients, like in an offset.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“rep”</code>
</dt>
<dd>
<p>
recycle the input vector to the length of the output vector as a <code>rep</code> function would.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>
<code>gradient</code>
</dt>
<dd>
<p>
is optional if <code>map</code> is constant or one of the predefined forms; otherwise, it must have one of the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric matrix with <code>length(params)</code> rows and <code>n</code> columns.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
to fix the gradient; this is useful when <code>map</code> is linear.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“linear”</code>
</dt>
<dd>
<p>
calculate the (constant) gradient matrix using finite differences. Note that this will be done only once at the initialization stage, so use only if you are certain <code>map</code> is, in fact, linear.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>
If the model in <code>formula</code> is curved, then the outputs of this operator term’s <code>map</code> argument will be used as inputs to the curved terms of the <code>formula</code> model.
</p>
<p>
<code>Curve</code> is an obsolete alias and may be deprecated and removed in a future release.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Parametrise_5">Parametrise(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf, cov=NULL)</a><br>
<p>
<em>Impose a curved structure on term parameters.</em>
</p>
<p>
<code>formula</code> is an arbitrary formula for a linear or curved ERGM. <code>params</code>, <code>map</code>, <code>gradient</code>, <code>minpar</code>, <code>maxpar</code>, and <code>cov</code> are the curved ERGM term API: a named list whose names are the curved parameter names, the mapping from curved to canonical, its gradient function, the minimum and the maximum allowed curved parameter values, and an optional “covariate” object.
</p>
<p>
Arguments may have the same forms as in the API, but for convenience, alternative forms are accepted.
</p>
<dl>
<dt>
<code>params</code>
</dt>
<dd>
<p>
may also be a character verctor with names.
</p>
</dd>
<dt>
<code>minpar</code> and <code>maxpar</code>
</dt>
<dd>
<p>
will be recycled to appropriate length.
</p>
</dd>
<dt>
<code>map</code>
</dt>
<dd>
<p>
may have the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric vector of length <code>n</code>.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
to fix the output coefficients, like in an offset.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“rep”</code>
</dt>
<dd>
<p>
recycle the input vector to the length of the output vector as a <code>rep</code> function would.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>
<code>gradient</code>
</dt>
<dd>
<p>
is optional if <code>map</code> is constant or one of the predefined forms; otherwise, it must have one of the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric matrix with <code>length(params)</code> rows and <code>n</code> columns.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
to fix the gradient; this is useful when <code>map</code> is linear.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“linear”</code>
</dt>
<dd>
<p>
calculate the (constant) gradient matrix using finite differences. Note that this will be done only once at the initialization stage, so use only if you are certain <code>map</code> is, in fact, linear.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>
If the model in <code>formula</code> is curved, then the outputs of this operator term’s <code>map</code> argument will be used as inputs to the curved terms of the <code>formula</code> model.
</p>
<p>
<code>Curve</code> is an obsolete alias and may be deprecated and removed in a future release.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Curve_6">Curve(formula, params, map, gradient=NULL, minpar=-Inf, maxpar=+Inf, cov=NULL)</a><br>
<p>
<em>Impose a curved structure on term parameters.</em>
</p>
<p>
<code>formula</code> is an arbitrary formula for a linear or curved ERGM. <code>params</code>, <code>map</code>, <code>gradient</code>, <code>minpar</code>, <code>maxpar</code>, and <code>cov</code> are the curved ERGM term API: a named list whose names are the curved parameter names, the mapping from curved to canonical, its gradient function, the minimum and the maximum allowed curved parameter values, and an optional “covariate” object.
</p>
<p>
Arguments may have the same forms as in the API, but for convenience, alternative forms are accepted.
</p>
<dl>
<dt>
<code>params</code>
</dt>
<dd>
<p>
may also be a character verctor with names.
</p>
</dd>
<dt>
<code>minpar</code> and <code>maxpar</code>
</dt>
<dd>
<p>
will be recycled to appropriate length.
</p>
</dd>
<dt>
<code>map</code>
</dt>
<dd>
<p>
may have the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric vector of length <code>n</code>.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
to fix the output coefficients, like in an offset.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“rep”</code>
</dt>
<dd>
<p>
recycle the input vector to the length of the output vector as a <code>rep</code> function would.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>
<code>gradient</code>
</dt>
<dd>
<p>
is optional if <code>map</code> is constant or one of the predefined forms; otherwise, it must have one of the following forms:
</p>
<dl>
<dt>
a <code>function(x, n, …)</code>
</dt>
<dd>
<p>
treated as in the API: called with <code>x</code> set to the curved parameter vector, <code>n</code> to the length of output expected, and <code>cov</code>, if present, passed in <code>…</code>. The function must return a numeric matrix with <code>length(params)</code> rows and <code>n</code> columns.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
to fix the gradient; this is useful when <code>map</code> is linear.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
to select (partially-matched) one of predefined forms. Currently, the defined forms include:
</p>
<dl>
<dt>
<code>“linear”</code>
</dt>
<dd>
<p>
calculate the (constant) gradient matrix using finite differences. Note that this will be done only once at the initialization stage, so use only if you are certain <code>map</code> is, in fact, linear.
</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>
If the model in <code>formula</code> is curved, then the outputs of this operator term’s <code>map</code> argument will be used as inputs to the curved terms of the <code>formula</code> model.
</p>
<p>
<code>Curve</code> is an obsolete alias and may be deprecated and removed in a future release.
</p>
</td>
<td>
valued, operator
</td>
</tr>
<tr>
<td>
<a id="term_Exp_1">Exp(formula)</a><br>
<p>
<em>Exponentiate a network’s statistic</em>: Evaluate the terms specified in <code>formula</code> and exponentiates them with base <i>e</i>.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Exp_2">Exp(formula)</a><br>
<p>
<em>Exponentiate a network’s statistic</em>: Evaluate the terms specified in <code>formula</code> and exponentiates them with base <i>e</i>.
</p>
</td>
<td>
valued, operator
</td>
</tr>
<tr>
<td>
<a id="term_F_1">F(formula, filter)</a><br>
<p>
<em>Filtering on arbitrary one-term model.</em> <code>filter</code> must contain one binary <code>ergm</code> term, with the following properties:
</p>
<ul>
<li>
<p>
dyadic independence;
</p>
</li>
<li>
<p>
dyadwise contribution of 0 for a 0-valued dyad.
</p>
</li>
</ul>
<p>
Formally, this means that it is expressable as
</p>
<p style="text-align: center;">
<i>sum[i,j] f[i,j] (y[i,j]),</i>
</p>
<p>
where for all <i>i</i>, <i>j</i>, and <i>y</i>, <i>f_{i,j}(y_{i,j})</i> for which <i>f[i,j] (0)=0</i>.
</p>
<p>
Examples of such terms include <code>nodemix</code>, <code>nodematch</code>, <code>nodefactor</code>, and <code>nodecov</code> and <code>edgecov</code> with appropriate covariates.
</p>
<p>
<code>formula</code> will be evaluated on a network constructed by taking <i>y</i> and removing any edges for which <i>f[i,j] (y[i,j])=0</i>.
</p>
<p>
For convenience, the term in <code>filter</code> can be a part of a simple logical or comparison operation: (e.g., <code>~!nodematch(“A”)</code> or <code>~absdiff(“X”)&gt;3</code>), which filters on <i>f[i,j] (y[i,j]) %OP% 0</i> instead.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Log_1">Log(formula, log0=-1/sqr)</a><br>
<p>
<em>Take a natural logarithm of a network’s statistic</em>: Evaluate the terms specified in <code>formula</code> and takes a natural (base <i>e</i>) logarithm of them. Since an ERGM statistic must be finite, <code>log0</code> specifies the value to be substituted for <code>log(0)</code>. The default value seems reasonable for most purposes.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Log_2">Log(formula, log0=-1/sqr)</a><br>
<p>
<em>Take a natural logarithm of a network’s statistic</em>: Evaluate the terms specified in <code>formula</code> and takes a natural (base <i>e</i>) logarithm of them. Since an ERGM statistic must be finite, <code>log0</code> specifies the value to be substituted for <code>log(0)</code>. The default value seems reasonable for most purposes.
</p>
</td>
<td>
valued, operator
</td>
</tr>
<tr>
<td>
<a id="term_Prod_1">Prod(formulas, label)</a><br>
<p>
<em>A product (or an arbitrary power combination) of one or more formulas</em>:
</p>
<p>
<code>formulas</code> is a list of formulas whose corresponding RHS statistics will be multiplied elementwise. They are required to be nonnegative.
</p>
<p>
If a formula has an LHS, it is interpreted as follows:
</p>
<dl>
<dt>
a numeric scalar
</dt>
<dd>
<p>
Network statistics of this formula will be exponentiated by this.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
Corresponding network statistics of this formula will be exponentiated by this.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
Vector of network statistics will be exponentiated by this using the same pattern as matrix multiplication.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
One of several predefined linear combinations. Currently supported presets are as follows:
</p>
<dl>
<dt>
<code>“prod”</code>
</dt>
<dd>
<p>
Network statistics of this formula will be multiplied together; equivalent to <code>matrix(1,1,p)</code>, where <code>p</code> is the length of the network statistic vector.
</p>
</dd>
<dt>
<code>“geomean”</code>
</dt>
<dd>
<p>
Network statistics of this formula will be geometrically averaged; equivalent to <code>matrix(1/p,1,p)</code>, where <code>p</code> is the length of the network statistic vector.
</p>
</dd>
</dl>
<p>
.
</p>
</dd>
</dl>
<p>
Note that each formula must either produce the same number of statistics or be mapped through a matrix to produce the same number of statistics.
</p>
<p>
A single formula is also permissible. This can be useful if one wishes to, say, multiply together the statistics returned by a formula.
</p>
<p>
Offsets are ignored unless there is only one formula and the transformation only exponentiates the statistics (i.e., the effective transformation matrix is diagonal).
</p>
<p>
<code>label</code> is used to specify the names of the elements of the resulting term sum vector. If <code>label</code> is a character vector of length 1, it will be recycled with indices appended. If <code>label</code> is a function, <code>formulas</code>’ parameter names are extracted and their list of character vectors is passed <code>label</code>. (For convenience, if only one formula is given, just a character vector is passed. Lastly, if <code>label</code> or result of its function call is an <code>AsIs</code> object, it is not wrapped in <code>Sum~…</code>.
</p>
<p>
Curved models are supported, subject to some limitations. In particular, the <em>first</em> model’s etamap will be used, overwriting the others. If <code>label</code> is not of length 1, it should have an <code>attr</code>-style attribute <code>“curved”</code> specifying the names for the curved parameters.
</p>
<p>
Note that the current implementation piggybacks on the <code>Log</code>, <code>Exp</code>, and <code>Sum</code> operators, essentially <code>Exp(<sub>Sum(</sub>Log(formula), label))</code>. This may result in loss of precision, particularly for extremely large or small statistics. The implementation may change in the future.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Prod_2">Prod(formulas, label)</a><br>
<p>
<em>A product (or an arbitrary power combination) of one or more formulas</em>:
</p>
<p>
<code>formulas</code> is a list of formulas whose corresponding RHS statistics will be multiplied elementwise. They are required to be nonnegative.
</p>
<p>
If a formula has an LHS, it is interpreted as follows:
</p>
<dl>
<dt>
a numeric scalar
</dt>
<dd>
<p>
Network statistics of this formula will be exponentiated by this.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
Corresponding network statistics of this formula will be exponentiated by this.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
Vector of network statistics will be exponentiated by this using the same pattern as matrix multiplication.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
One of several predefined linear combinations. Currently supported presets are as follows:
</p>
<dl>
<dt>
<code>“prod”</code>
</dt>
<dd>
<p>
Network statistics of this formula will be multiplied together; equivalent to <code>matrix(1,1,p)</code>, where <code>p</code> is the length of the network statistic vector.
</p>
</dd>
<dt>
<code>“geomean”</code>
</dt>
<dd>
<p>
Network statistics of this formula will be geometrically averaged; equivalent to <code>matrix(1/p,1,p)</code>, where <code>p</code> is the length of the network statistic vector.
</p>
</dd>
</dl>
<p>
.
</p>
</dd>
</dl>
<p>
Note that each formula must either produce the same number of statistics or be mapped through a matrix to produce the same number of statistics.
</p>
<p>
A single formula is also permissible. This can be useful if one wishes to, say, multiply together the statistics returned by a formula.
</p>
<p>
Offsets are ignored unless there is only one formula and the transformation only exponentiates the statistics (i.e., the effective transformation matrix is diagonal).
</p>
<p>
<code>label</code> is used to specify the names of the elements of the resulting term sum vector. If <code>label</code> is a character vector of length 1, it will be recycled with indices appended. If <code>label</code> is a function, <code>formulas</code>’ parameter names are extracted and their list of character vectors is passed <code>label</code>. (For convenience, if only one formula is given, just a character vector is passed. Lastly, if <code>label</code> or result of its function call is an <code>AsIs</code> object, it is not wrapped in <code>Sum~…</code>.
</p>
<p>
Curved models are supported, subject to some limitations. In particular, the <em>first</em> model’s etamap will be used, overwriting the others. If <code>label</code> is not of length 1, it should have an <code>attr</code>-style attribute <code>“curved”</code> specifying the names for the curved parameters.
</p>
<p>
Note that the current implementation piggybacks on the <code>Log</code>, <code>Exp</code>, and <code>Sum</code> operators, essentially <code>Exp(<sub>Sum(</sub>Log(formula), label))</code>. This may result in loss of precision, particularly for extremely large or small statistics. The implementation may change in the future.
</p>
</td>
<td>
valued, operator
</td>
</tr>
<tr>
<td>
<a id="term_S_1">S(formula, attrs)</a><br>
<p>
<em>Evaluation on an induced subgraph</em>:
</p>
<p>
<code>attrs</code> is a two-sided formula whose LHS gives the attribute or attribute function (see Specifying Vertex Attributes and Levels) for which tails and heads will be used to construct the induced subgraph. A one-sided formula (e.g., <code>~A</code>) is symmetrized (e.g., <code>A~A</code>).
</p>
<p>
It should evaluate either to a logical vector equal in length to the number of tails (for LHS) and heads (for RHS) indicating which nodes are to be used to induce the subgraph or a numeric vector giving their indices. (As with indexing vectors, the logical vector will be recycled to the size of the network or the size of the appropriate bipartition, and negative indices will deselect vertices.)
</p>
<p>
When the two sets are identical, the induced subgraph retains the directedness of the original graph. Otherwise, an undirected bipartite graph is induced.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Sum_1">Sum(formulas, label)</a><br>
<p>
<em>A sum (or an arbitrary linear combination) of one or more formulas</em>:
</p>
<p>
<code>formulas</code> is a list of formulas whose corresponding RHS statistics will be summed elementwise.
</p>
<p>
If a formula has an LHS, it is interpreted as follows:
</p>
<dl>
<dt>
a numeric scalar
</dt>
<dd>
<p>
Network statistics of this formula will be multiplied by this.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
Corresponding network statistics of this formula will be multiplied by this.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
Vector of network statistics will be pre-multiplied by this.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
One of several predefined linear combinations. Currently supported presets are as follows:
</p>
<dl>
<dt>
<code>“sum”</code>
</dt>
<dd>
<p>
Network statistics of this formula will be summed up; equivalent to <code>matrix(1,1,p)</code>, where <code>p</code> is the length of the network statistic vector.
</p>
</dd>
<dt>
<code>“mean”</code>
</dt>
<dd>
<p>
Network statistics of this formula will be averaged; equivalent to <code>matrix(1/p,1,p)</code>, where <code>p</code> is the length of the network statistic vector.
</p>
</dd>
</dl>
<p>
.
</p>
</dd>
</dl>
<p>
Note that each formula must either produce the same number of statistics or be mapped through a matrix to produce the same number of statistics.
</p>
<p>
A single formula is also permitted. This can be useful if one wishes to, say, scale or sum up the statistics returned by a formula.
</p>
<p>
Offsets are ignored unless there is only one formula and the transformation only scales the statistics (i.e., the effective transformation matrix is diagonal).
</p>
<p>
<code>label</code> is used to specify the names of the elements of the resulting term sum vector. If <code>label</code> is a character vector of length 1, it will be recycled with indices appended. If <code>label</code> is a function, <code>formulas</code>’ parameter names are extracted and their list of character vectors is passed <code>label</code>. (For convenience, if only one formula is given, just a character vector is passed. Lastly, if <code>label</code> or result of its function call is an <code>AsIs</code> object, it is not wrapped in <code>Sum~…</code>.
</p>
<p>
Curved models are supported, subject to some limitations. In particular, the <em>first</em> model’s etamap will be used, overwriting the others. If <code>label</code> is not of length 1, it should have an <code>attr</code>-style attribute <code>“curved”</code> specifying the names for the curved parameters.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Sum_2">Sum(formulas, label)</a><br>
<p>
<em>A sum (or an arbitrary linear combination) of one or more formulas</em>:
</p>
<p>
<code>formulas</code> is a list of formulas whose corresponding RHS statistics will be summed elementwise.
</p>
<p>
If a formula has an LHS, it is interpreted as follows:
</p>
<dl>
<dt>
a numeric scalar
</dt>
<dd>
<p>
Network statistics of this formula will be multiplied by this.
</p>
</dd>
<dt>
a numeric vector
</dt>
<dd>
<p>
Corresponding network statistics of this formula will be multiplied by this.
</p>
</dd>
<dt>
a numeric matrix
</dt>
<dd>
<p>
Vector of network statistics will be pre-multiplied by this.
</p>
</dd>
<dt>
a character string
</dt>
<dd>
<p>
One of several predefined linear combinations. Currently supported presets are as follows:
</p>
<dl>
<dt>
<code>“sum”</code>
</dt>
<dd>
<p>
Network statistics of this formula will be summed up; equivalent to <code>matrix(1,1,p)</code>, where <code>p</code> is the length of the network statistic vector.
</p>
</dd>
<dt>
<code>“mean”</code>
</dt>
<dd>
<p>
Network statistics of this formula will be averaged; equivalent to <code>matrix(1/p,1,p)</code>, where <code>p</code> is the length of the network statistic vector.
</p>
</dd>
</dl>
<p>
.
</p>
</dd>
</dl>
<p>
Note that each formula must either produce the same number of statistics or be mapped through a matrix to produce the same number of statistics.
</p>
<p>
A single formula is also permitted. This can be useful if one wishes to, say, scale or sum up the statistics returned by a formula.
</p>
<p>
Offsets are ignored unless there is only one formula and the transformation only scales the statistics (i.e., the effective transformation matrix is diagonal).
</p>
<p>
<code>label</code> is used to specify the names of the elements of the resulting term sum vector. If <code>label</code> is a character vector of length 1, it will be recycled with indices appended. If <code>label</code> is a function, <code>formulas</code>’ parameter names are extracted and their list of character vectors is passed <code>label</code>. (For convenience, if only one formula is given, just a character vector is passed. Lastly, if <code>label</code> or result of its function call is an <code>AsIs</code> object, it is not wrapped in <code>Sum~…</code>.
</p>
<p>
Curved models are supported, subject to some limitations. In particular, the <em>first</em> model’s etamap will be used, overwriting the others. If <code>label</code> is not of length 1, it should have an <code>attr</code>-style attribute <code>“curved”</code> specifying the names for the curved parameters.
</p>
</td>
<td>
valued, operator
</td>
</tr>
<tr>
<td>
<a id="term_Symmetrize_1">Symmetrize(formula, rule=“weak”)</a><br>
<p>
<em>Evaluation on symmetrized (undirected) network</em>: Evaluates the terms in <code>formula</code> on an undirected network constructed by symmetrizing the LHS network using one of four rules:
</p>
<dl>
<dt>
<code>“weak”</code>
</dt>
<dd>
<p>
A tie <i>(i,j)</i> is present in the constructed network if the LHS network has either tie <i>(i,j)</i> or <i>(j,i)</i> (or both).
</p>
</dd>
<dt>
<code>“strong”</code>
</dt>
<dd>
<p>
A tie <i>(i,j)</i> is present in the constructed network if the LHS network has both tie <i>(i,j)</i> and tie <i>(j,i)</i>.
</p>
</dd>
<dt>
<code>“upper”</code>
</dt>
<dd>
<p>
A tie <i>(i,j)</i> is present in the constructed network if the LHS network has tie <i>((i,j),(i,j))</i>: the upper triangle of the LHS network.
</p>
</dd>
<dt>
<code>“upper”</code>
</dt>
<dd>
<p>
A tie <i>(i,j)</i> is present in the constructed network if the LHS network has tie <i>((i,j),(i,j))</i>: the lower triangle of the LHS network.
</p>
</dd>
</dl>
</p>
</td>
<td>
binary, directed, operator
</td>
</tr>
<tr>
<td>
<a id="term_Label_1">Label(formula, label, pos)</a><br>
<p>
<em>Modify terms’ coefficient names</em>: The <code>Label</code> operator evaluates <code>formula</code> without modification, but modifies its coefficient and/or parameter names based on <code>label</code> and <code>pos</code>. <code>label</code> is either a character vector specifying the label for the terms or a function through which term names are mapped (or a <code>as_mapper</code>-style formula). If it is a character vector, the <code>pos</code> argument controls how it modifies the term naes: one of <code>“prepend”</code>, <code>“replace”</code>, <code>“append”</code>, or <code>“(”</code>, with the latter wrapping the term names in parentheses like a function call with name specified by <code>label</code>.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Label_2">Label(formula, label, pos)</a><br>
<p>
<em>Modify terms’ coefficient names</em>: The <code>Label</code> operator evaluates <code>formula</code> without modification, but modifies its coefficient and/or parameter names based on <code>label</code> and <code>pos</code>. <code>label</code> is either a character vector specifying the label for the terms or a function through which term names are mapped (or a <code>as_mapper</code>-style formula). If it is a character vector, the <code>pos</code> argument controls how it modifies the term naes: one of <code>“prepend”</code>, <code>“replace”</code>, <code>“append”</code>, or <code>“(”</code>, with the latter wrapping the term names in parentheses like a function call with name specified by <code>label</code>.
</p>
</td>
<td>
valued, operator
</td>
</tr>
<tr>
<td>
<a id="term_NodematchFilter_1">NodematchFilter(formula, attrname)</a><br>
<p>
<em>Filtering on <code>nodematch</code></em>: evaluates the terms specified in <code>formula</code> on a network constructed by taking <i>y</i> and removing any edges for which <code>attrname(i)!=attrname(j)</code>. The <code>attrname</code> argument is a character vector giving one or more names of attributes in the network’s vertex attribute list.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_Offset_1">Offset(formula, coef, which)</a><br>
<p>
<em>Terms with fixed coefficients</em>: This operator is analogous to the <code>offset()</code> wrapper, but the coefficients are specified within the term and the curved ERGM mechanism is used internally. In addition, the <code>which</code> argument can be used to specify which of the <em>parameters</em> in the formula are fixed. It can be a logical vector (recycled as needed), a numeric vector of indices of parameters to be fixed, or a character vector of parameter names.
</p>
</td>
<td>
binary, operator
</td>
</tr>
<tr>
<td>
<a id="term_absdiff_1">absdiff(attr, pow=1)</a><br>
<p>
<em>Absolute difference:</em> The <code>attr</code> argument specifies a quantitative attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds one network statistic to the model equaling the sum of <code>abs(attr[i]-attr[j])^pow</code> for all edges (i,j) in the network.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
binary, dyad-independent, frequently-used, directed, undirected, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_absdiff_2">absdiff(attr, pow=1, form =“sum”)</a><br>
<p>
<em>Absolute difference:</em> The <code>attr</code> argument specifies a quantitative attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds one network statistic to the model equaling the sum of <code>abs(attr[i]-attr[j])^pow</code> for all edges (i,j) in the network.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
valued, dyad-independent, directed, undirected, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_absdiffcat_1">absdiffcat(attr, base=NULL, levels=NULL)</a><br>
<p>
<em>Categorical absolute difference:</em> The <code>attr</code> argument specifies a quantitative attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds one statistic for every possible nonzero distinct value of <code>abs(attr[i]-attr[j])</code> in the network; the value of each such statistic is the number of edges in the network with the corresponding absolute difference. The optional argument <code>levels</code> specifies which nonzero differences to include in or exclude from the model (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). For example, if the possible values of <code>abs(attr[i]-attr[j])</code> are 0, 0.5, 3, 3.5, and 10, then to omit 0.5 and 10 one could set <code>levels=2:3</code> (we wish to retain the second and third nonzero difference, when differences are sorted in increasing order). Note that this term should generally be used only when the quantitative attribute has a limited number of possible values; an example is the <code>“Grade”</code> attribute of the <code>faux.mesa.high</code> or <code>faux.magnolia.high</code> datasets.
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_absdiffcat_2">absdiffcat(attr, base=NULL, levels=NULL, form=“sum”)</a><br>
<p>
<em>Categorical absolute difference:</em> The <code>attr</code> argument specifies a quantitative attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds one statistic for every possible nonzero distinct value of <code>abs(attr[i]-attr[j])</code> in the network; the value of each such statistic is the number of edges in the network with the corresponding absolute difference. The optional argument <code>levels</code> specifies which nonzero differences to include in or exclude from the model (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). For example, if the possible values of <code>abs(attr[i]-attr[j])</code> are 0, 0.5, 3, 3.5, and 10, then to omit 0.5 and 10 one could set <code>levels=2:3</code> (we wish to retain the second and third nonzero difference, when differences are sorted in increasing order). Note that this term should generally be used only when the quantitative attribute has a limited number of possible values; an example is the <code>“Grade”</code> attribute of the <code>faux.mesa.high</code> or <code>faux.magnolia.high</code> datasets.
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
</td>
<td>
valued, dyad-independent, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_altkstar_1">altkstar(lambda, fixed=FALSE)</a><br>
<p>
<em>Alternating k-star:</em> This term adds one network statistic to the model equal to a weighted alternating sequence of k-star statistics with weight parameter <code>lambda</code>. This is the version given in Snijders et al. (2006). The <code>gwdegree</code> and <code>altkstar</code> produce mathematically equivalent models, as long as they are used together with the <code>edges</code> (or <code>kstar(1)</code>) term, yet the interpretation of the <code>gwdegree</code> parameters is slightly more straightforward than the interpretation of the <code>altkstar</code> parameters. For this reason, we recommend the use of the <code>gwdegree</code> instead of <code>altkstar</code>. See Section 3 and especially equation (13) of Hunter (2007) for details. The optional argument <code>fixed</code> indicates whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved exponential family model (see Hunter and Handcock, 2006). The default is <code>FALSE</code>, which means the scale parameter is not fixed and thus the model is a CEF model. This term can only be used with undirected networks.
</p>
</td>
<td>
binary, undirected, curved, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_asymmetric_1">asymmetric(attr=NULL, diff=FALSE, keep=NULL, levels=NULL)</a><br>
<p>
<em>Asymmetric dyads:</em> This term adds one network statistic to the model equal to the number of pairs of actors for which exactly one of <i>(i,j)</i> or <i>(j,i)</i> exists. This term can only be used with directed networks. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If <code>attr</code> is specified, only asymmetric pairs that match on the vertex attribute <code>attr</code> are counted. The optional modifiers <code>diff</code> and <code>levels</code> are used in the same way as for the <code>nodematch</code> term; refer to this term for details and an example.
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>.
</p>
</td>
<td>
binary, directed, dyad-independent, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_atleast_1">atleast(threshold=0)</a><br>
<p>
<em>Number of dyads with values greater than or equal to a threshold</em> Adds the number of statistics equal to the length of <code>threshold</code> equaling to the number of dyads whose values equal or exceed the corresponding element of <code>threshold</code>.
</p>
</td>
<td>
valued, directed, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_atmost_1">atmost(threshold=0)</a><br>
<p>
<em>Number of dyads with values less than or equal to a threshold</em> Adds the number of statistics equal to the length of <code>threshold</code> equaling to the number of dyads whose values equal or are exceeded by the corresponding element of <code>threshold</code>.
</p>
</td>
<td>
valued, directed, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_attrcov_1">attrcov(attr, mat)</a><br>
<p>
<em>Edge covariate by attribute pairing:</em> The <code>attr</code> argument specifies a vertex attribute (see Specifying Vertex Attributes and Levels for details), and the <code>mat</code> argument is a matrix of covariates with the same dimensions as a mixing matrix for <code>attr</code>. This term adds one statistic to the model, equal to the sum of the covariate values for each edge appearing in the network, where the covariate value for a given edge is determined by its mixing type on <code>attr</code>. Undirected networks are regarded as having undirected mixing, and it is assumed that <code>mat</code> is symmetric in that case.
</p>
<p>
This term can be useful for simulating large networks with many mixing types, where <code>nodemix</code> would be slow due to the large number of statistics, and <code>edgecov</code> cannot be used because an adjacency matrix would be too big.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_b1concurrent_1">b1concurrent(by=NULL, levels=NULL)</a><br>
<p>
<em>Concurrent node count for the first mode in a bipartite (aka two-mode) network:</em> This term adds one network statistic to the model, equal to the number of nodes in the first mode of the network with degree 2 or higher. The first mode of a bipartite network object is sometimes known as the “actor” mode. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details); it functions just like the <code>by</code> argument of the <code>b1degree</code> term. Without the optional argument, this statistic is equivalent to <code>b1mindegree(2)</code>. This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_b1cov_1">b1cov(attr)</a><br>
<p>
<em>Main effect of a covariate for the first mode in a bipartite (aka two-mode) network:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total value of <code>attr(i)</code> for all edges <i>(i,j)</i> in the network. This term may only be used with bipartite networks. For categorical attributes, see <code>b1factor</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
binary, undirected, bipartite, dyad-independent, quantitative nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b1cov_2">b1cov(attr, form=“sum”)</a><br>
<p>
<em>Main effect of a covariate for the first mode in a bipartite (aka two-mode) network:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total value of <code>attr(i)</code> for all edges <i>(i,j)</i> in the network. This term may only be used with bipartite networks. For categorical attributes, see <code>b1factor</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
valued, undirected, bipartite, dyad-independent, quantitative nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b1degrange_1">b1degrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)</a><br>
<p>
<em>Degree range for the first mode in a bipartite (a.k.a. two-mode) network:</em> The <code>from</code> and <code>to</code> arguments are vectors of distinct integers (or <code>+Inf</code>, for <code>to</code> (its default)). If one of the vectors has length 1, it is recycled to the length of the other. Otherwise, they must have the same length. This term adds one network statistic to the model for each element of <code>from</code> (or <code>to</code>); the <i>i</i>th such statistic equals the number of nodes of the first mode (“actors”) in the network of degree greater than or equal to <code>from[i]</code> but strictly less than <code>to[i]</code>, i.e. with edge count in semiopen interval <code>[from,to)</code>. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified and <code>homophily</code> is <code>TRUE</code>, then degrees are calculated using the subnetwork consisting of only edges whose endpoints have the same value of the <code>by</code> attribute. If <code>by</code> is specified and <code>homophily</code> is <code>FALSE</code> (the default), then separate degree range statistics are calculated for nodes having each separate value of the attribute.
</p>
<p>
This term can only be used with bipartite networks; for directed networks see <code>idegrange</code> and <code>odegrange</code>. For undirected networks, see <code>degrange</code>, and see <code>b2degrange</code> for degrees of the second mode (“events”).
</p>
</td>
<td>
binary, bipartite, undirected
</td>
</tr>
<tr>
<td>
<a id="term_b1degree_1">b1degree(d, by=NULL, levels=NULL)</a><br>
<p>
<em>Degree for the first mode in a bipartite (aka two-mode) network:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of nodes of degree <code>d[i]</code> in the first mode of a bipartite network, i.e. with exactly <code>d[i]</code> edges. The first mode of a bipartite network object is sometimes known as the “actor” mode. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified then each node’s degree is tabulated only with other nodes having the same value of the <code>by</code> attribute.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b1dsp_1">b1dsp(d)</a><br>
<p>
<em>Dyadwise shared partners for dyads in the first bipartition:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of dyads in the first bipartition with exactly <code>d[i]</code> shared partners. (Those shared partners, of course, must be members of the second bipartition.) This term can only be used with bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected
</td>
</tr>
<tr>
<td>
<a id="term_b1factor_1">b1factor(attr, base=1, levels=-1)</a><br>
<p>
<em>Factor attribute effect for the first mode in a bipartite (aka two-mode) network:</em> The <code>attr</code> argument specifies a categorical vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute. Each of these statistics gives the number of times a node with that attribute in the first mode of the network appears in an edge. The first mode of a bipartite network object is sometimes known as the “actor” mode.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>b1factor(“fruit”, levels=-(2:3))</code>, <code>b1factor(“fruit”, levels=c(1,4))</code>, and <code>b1factor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, dyad-independent, frequently-used, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_b1factor_2">b1factor(attr, base=1, levels=-1, form=“sum”)</a><br>
<p>
<em>Factor attribute effect for the first mode in a bipartite (aka two-mode) network:</em> The <code>attr</code> argument specifies a categorical vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute. Each of these statistics gives the number of times a node with that attribute in the first mode of the network appears in an edge. The first mode of a bipartite network object is sometimes known as the “actor” mode.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>b1factor(“fruit”, levels=-(2:3))</code>, <code>b1factor(“fruit”, levels=c(1,4))</code>, and <code>b1factor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
valued, bipartite, undirected, dyad-independent, frequently-used, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_b1mindegree_1">b1mindegree(d)</a><br>
<p>
<em>Minimum degree for the first mode in a bipartite (aka two-mode) network:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of nodes in the first mode of a bipartite network with at least degree <code>d[i]</code>. The first mode of a bipartite network object is sometimes known as the “actor” mode.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected
</td>
</tr>
<tr>
<td>
<a id="term_b1nodematch_1">b1nodematch(attr, diff=FALSE, keep=NULL, alpha=1, beta=1,)</a><br>
<p>
<em>Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network:</em> This term is introduced in Bomiriya et al (2014). The <code>attr</code> argument specifies a categorical vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). Out of the two arguments (discount parameters) <code>alpha</code> and <code>beta</code>, both of which take values from [0,1], only one should be set at a time. If none is set to a value other than 1, this term will simply be a homophily based two-star statistic. This term adds one statistic to the model unless <code>diff</code> is set to <code>TRUE</code>, in which case the term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute. To include only the attribute values you wish, use the <code>levels</code> arguments.
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>.
</p>
<p>
If an <code>alpha</code> discount parameter is used, each of these statistics gives the sum of the number of common second-mode nodes raised to the power <code>alpha</code> for each pair of first-mode nodes with that attribute. If a <code>beta</code> discount parameter is used, each of these statistics gives half the sum of the number of two-paths with two first-mode nodes with that attribute as the two ends of the two path raised to the power <code>beta</code> for each edge in the network. The <code>byb2attr</code> argument specifies a second mode categorical attribute. Setting this argument will separate the orginal statistics based on the values of the set second mode attribute— i.e. for example, if <code>diff</code> is <code>FALSE</code>, then the sum of all the statistics for each level of this second-mode attribute will be equal to the original <code>b1nodematch</code> statistic where <code>byb2attr</code> set to <code>NULL</code>. This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, dyad-independent, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b1sociality_1">b1sociality(nodes=-1)</a><br>
<p>
<em>Degree:</em> This term adds one network statistic for each node in the first bipartition, equal to the number of ties of that node. By default, <code>nodes=-1</code> means that the statistic for the first node will be omitted, but this argument may be changed to control which statistics are included. The <code>nodes</code> argument is interpreted using the new UI for level specification (see Specifying Vertex Attributes and Levels for details), where both the attribute and the sorted unique values are the vector of vertex indices <code>1:nb1</code>, where <code>nb1</code> is the size of the first bipartition. This term can only be used with bipartite networks. For directed networks, see <code>sender</code> and <code>receiver</code>. For unipartite networks, see <code>sociality</code>.
</p>
</td>
<td>
binary, bipartite, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_b1sociality_2">b1sociality(nodes=-1, form=“sum”)</a><br>
<p>
<em>Degree:</em> This term adds one network statistic for each node in the first bipartition, equal to the number of ties of that node. By default, <code>nodes=-1</code> means that the statistic for the first node will be omitted, but this argument may be changed to control which statistics are included. The <code>nodes</code> argument is interpreted using the new UI for level specification (see Specifying Vertex Attributes and Levels for details), where both the attribute and the sorted unique values are the vector of vertex indices <code>1:nb1</code>, where <code>nb1</code> is the size of the first bipartition. This term can only be used with bipartite networks. For directed networks, see <code>sender</code> and <code>receiver</code>. For unipartite networks, see <code>sociality</code>.
</p>
</td>
<td>
valued, bipartite, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_b1star_1">b1star(k, attr=NULL, levels=NULL)</a><br>
<p>
<em>k-Stars for the first mode in a bipartite (aka two-mode) network:</em> The <code>k</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>k</code>. The <i>i</i>th such statistic counts the number of distinct <code>k[i]</code>-stars whose center node is in the first mode of the network. The first mode of a bipartite network object is sometimes known as the “actor” mode. A <i>k</i>-star is defined to be a center node <i>N</i> and a set of <i>k</i> different nodes <i>{O[1], …, O[k]}</i> such that the ties <i>{N, O[i]}</i> exist for <i>i=1, …, k</i>. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified then the count is over the number of <i>k</i>-stars (with center node in the first mode) where all nodes have the same value of the attribute. This term can only be used for undirected bipartite networks. Note that <code>b1star(1)</code> is equal to <code>b2star(1)</code> and to <code>edges</code>.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_b1starmix_1">b1starmix(k, attr, base=NULL, diff=TRUE)</a><br>
<p>
<em> Mixing matrix for k-stars centered on the first mode of a bipartite network:</em> Only a single value of <i>k</i> is allowed. This term counts all k-stars in which the b2 nodes (called events in some contexts) are homophilous in the sense that they all share the same value of <code>attr</code>. However, the b1 node (in some contexts, the actor) at the center of the k-star does NOT have to have the same value as the b2 nodes; indeed, the values taken by the b1 nodes may be completely distinct from those of the b2 nodes, which allows for the use of this term in cases where there are two separate nodal attributes, one for the b1 nodes and another for the b2 nodes (in this case, however, these two attributes should be combined to form a single nodal attribute, <code>attr</code>). A different statistic is created for each value of <code>attr</code> seen in a b1 node, even if no k-stars are observed with this value. Whether a different statistic is created for each value seen in a b2 node depends on the value of the <code>diff</code> argument: When <code>diff=TRUE</code>, the default, a different statistic is created for each value and thus the behavior of this term is reminiscent of the <code>nodemix</code> term, from which it takes its name; when <code>diff=FALSE</code>, all homophilous k-stars are counted together, though these k-stars are still categorized according to the value of the central b1 node.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_b1twostar_1">b1twostar(b1attr, b2attr, base=NULL, b1levels=NULL, b2levels=NULL, levels2=NULL)</a><br>
<p>
<em> Two-star census for central nodes centered on the first mode of a bipartite network:</em> This term takes two nodal attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details), one for b1 nodes (actors in some contexts) and one for b2 nodes (events in some contexts). Only <code>b1attr</code> is required; if <code>b2attr</code> is not passed, it is assumed to be the same as <code>b1attr</code>. Assuming that there are <i>n_1</i> values of <code>b1attr</code> among the b1 nodes and <i>n_2</i> values of <code>b2attr</code> among the b2 nodes, then the total number of distinct categories of two stars according to these two attributes is <i>n_1(n_2)(n_2+1)/2</i>. By default, this model term creates a distinct statistic counting each of these categories. The <code>b1levels</code>, <code>b2levels</code>, <code>base</code>, and <code>levels2</code> arguments may be used to leave some of these categories out (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>. The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels2</code> are passed, <code>levels2</code> overrides <code>base</code>.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_b2concurrent_1">b2concurrent(by=NULL)</a><br>
<p>
<em>Concurrent node count for the second mode in a bipartite (aka two-mode) network:</em> This term adds one network statistic to the model, equal to the number of nodes in the second mode of the network with degree 2 or higher. The second mode of a bipartite network object is sometimes known as the “event” mode. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details); it functions just like the <code>by</code> argument of the <code>b2degree</code> term. Without the optional argument, this statistic is equivalent to <code>b2mindegree(2)</code>.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b2cov_1">b2cov(attr)</a><br>
<p>
<em>Main effect of a covariate for the second mode in a bipartite (aka two-mode) network:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total value of <code>attr(j)</code> for all edges <i>(i,j)</i> in the network. This term may only be used with bipartite networks. For categorical attributes, see <code>b2factor</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
binary, undirected, bipartite, dyad-independent, quantitative nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b2cov_2">b2cov(attr, form=“sum”)</a><br>
<p>
<em>Main effect of a covariate for the second mode in a bipartite (aka two-mode) network:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total value of <code>attr(j)</code> for all edges <i>(i,j)</i> in the network. This term may only be used with bipartite networks. For categorical attributes, see <code>b2factor</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
valued, undirected, bipartite, dyad-independent, quantitative nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b2degrange_1">b2degrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)</a><br>
<p>
<em>Degree range for the second mode in a bipartite (a.k.a. two-mode) network:</em> The <code>from</code> and <code>to</code> arguments are vectors of distinct integers (or <code>+Inf</code>, for <code>to</code> (its default)). If one of the vectors has length 1, it is recycled to the length of the other. Otherwise, they must have the same length. This term adds one network statistic to the model for each element of <code>from</code> (or <code>to</code>); the <i>i</i>th such statistic equals the number of nodes of the second mode (“events”) in the network of degree greater than or equal to <code>from[i]</code> but strictly less than <code>to[i]</code>, i.e. with edge count in semiopen interval <code>[from,to)</code>. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified and <code>homophily</code> is <code>TRUE</code>, then degrees are calculated using the subnetwork consisting of only edges whose endpoints have the same value of the <code>by</code> attribute. If <code>by</code> is specified and <code>homophily</code> is <code>FALSE</code> (the default), then separate degree range statistics are calculated for nodes having each separate value of the attribute.
</p>
<p>
This term can only be used with bipartite networks; for directed networks see <code>idegrange</code> and <code>odegrange</code>. For undirected networks, see <code>degrange</code>, and see <code>b1degrange</code> for degrees of the first mode (“actors”).
</p>
</td>
<td>
binary, bipartite, undirected
</td>
</tr>
<tr>
<td>
<a id="term_b2degree_1">b2degree(d, by=NULL)</a><br>
<p>
<em>Degree for the second mode in a bipartite (aka two-mode) network:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of nodes of degree <code>d[i]</code> in the second mode of a bipartite network, i.e. with exactly <code>d[i]</code> edges. The second mode of a bipartite network object is sometimes known as the “event” mode. The optional term <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified then each node’s degree is tabulated only with other nodes having the same value of the <code>by</code> attribute.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b2dsp_1">b2dsp(d)</a><br>
<p>
<em>Dyadwise shared partners for dyads in the second bipartition:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of dyads in the second bipartition with exactly <code>d[i]</code> shared partners. (Those shared partners, of course, must be members of the first bipartition.) This term can only be used with bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected
</td>
</tr>
<tr>
<td>
<a id="term_b2factor_1">b2factor(attr, base=1, levels=-1)</a><br>
<p>
<em>Factor attribute effect for the second mode in a bipartite (aka two-mode) network :</em> The <code>attr</code> argument specifies a categorical vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute. Each of these statistics gives the number of times a node with that attribute in the second mode of the network appears in an edge. The second mode of a bipartite network object is sometimes known as the “event” mode.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>b2factor(“fruit”, levels=-(2:3))</code>, <code>b2factor(“fruit”, levels=c(1,4))</code>, and <code>b2factor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, dyad-independent, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b2factor_2">b2factor(attr, base=1, levels=-1, form=“sum”)</a><br>
<p>
<em>Factor attribute effect for the second mode in a bipartite (aka two-mode) network :</em> The <code>attr</code> argument specifies a categorical vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute. Each of these statistics gives the number of times a node with that attribute in the second mode of the network appears in an edge. The second mode of a bipartite network object is sometimes known as the “event” mode.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>b2factor(“fruit”, levels=-(2:3))</code>, <code>b2factor(“fruit”, levels=c(1,4))</code>, and <code>b2factor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
valued, bipartite, undirected, dyad-independent, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b2mindegree_1">b2mindegree(d)</a><br>
<p>
<em>Minimum degree for the second mode in a bipartite (aka two-mode) network:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of nodes in the second mode of a bipartite network with at least degree <code>d[i]</code>. The second mode of a bipartite network object is sometimes known as the “event” mode.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected
</td>
</tr>
<tr>
<td>
<a id="term_b2nodematch_1">b2nodematch(attr, diff=FALSE, keep=NULL, alpha=1, beta=1,)</a><br>
<p>
<em>Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network:</em> This term is introduced in Bomiriya et al (2014). The <code>attr</code> argument specifies a categorical vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). Out of the two arguments (discount parameters) <code>alpha</code> and <code>beta</code>, both which takes values from [0,1], only one should be set at a time. If none is set to a value other than 1, this term will simply be a homophily based two-star statistic. This term adds one statistic to the model unless <code>diff</code> is set to <code>TRUE</code>, in which case the term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute. To include only the attribute values you wish, use the <code>levels</code> argument.
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>.
</p>
<p>
If an <code>alpha</code> discount parameter is used, each of these statistics gives the sum of the number of common first-mode nodes raised to the power <code>alpha</code> for each pair of second-mode nodes with that attribute. If a <code>beta</code> discount parameter is used, each of these statistics gives half the sum of the number of two-paths with two second-mode nodes with that attribute as the two ends of the two path raised to the power <code>beta</code> for each edge in the network. The <code>byb1attr</code> argument specifies a first mode categorical attribute. Setting this argument will separate the orginal statistics based on the values of the set first mode attribute— i.e. for example, if <code>diff</code> is <code>FALSE</code>, then the sum of all the statistics for each level of this first-mode attribute will be equal to the original <code>b2nodematch</code> statistic where <code>byb1attr</code> set to <code>NULL</code>.
</p>
<p>
This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, dyad-independent, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_b2sociality_1">b2sociality(nodes=-1)</a><br>
<p>
<em>Degree:</em> This term adds one network statistic for each node in the second bipartition, equal to the number of ties of that node. By default, <code>nodes=-1</code> means that the statistic for the first node (in the second bipartition) will be omitted, but this argument may be changed to control which statistics are included. The <code>nodes</code> argument is interpreted using the new UI for level specification (see Specifying Vertex Attributes and Levels for details), where both the attribute and the sorted unique values are the vector of vertex indices <code>(nb1 + 1):n</code>, where <code>nb1</code> is the size of the first bipartition and <code>n</code> is the total number of nodes in the network. Thus <code>nodes=120</code> will include only the statistic for the 120th node in the second biparition, while <code>nodes=I(120)</code> will include only the statistic for the 120th node in the entire network. This term can only be used with undirected bipartite networks. For directed networks, see <code>sender</code> and <code>receiver</code>. For unipartite networks, see <code>sociality</code>.
</p>
</td>
<td>
binary, bipartite, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_b2sociality_2">b2sociality(nodes=-1, form=“sum”)</a><br>
<p>
<em>Degree:</em> This term adds one network statistic for each node in the second bipartition, equal to the number of ties of that node. By default, <code>nodes=-1</code> means that the statistic for the first node (in the second bipartition) will be omitted, but this argument may be changed to control which statistics are included. The <code>nodes</code> argument is interpreted using the new UI for level specification (see Specifying Vertex Attributes and Levels for details), where both the attribute and the sorted unique values are the vector of vertex indices <code>(nb1 + 1):n</code>, where <code>nb1</code> is the size of the first bipartition and <code>n</code> is the total number of nodes in the network. Thus <code>nodes=120</code> will include only the statistic for the 120th node in the second biparition, while <code>nodes=I(120)</code> will include only the statistic for the 120th node in the entire network. This term can only be used with undirected bipartite networks. For directed networks, see <code>sender</code> and <code>receiver</code>. For unipartite networks, see <code>sociality</code>.
</p>
</td>
<td>
valued, bipartite, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_b2star_1">b2star(k, attr=NULL, levels=NULL)</a><br>
<p>
<em>k-Stars for the second mode in a bipartite (aka two-mode) network:</em> The <code>k</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>k</code>. The <i>i</i>th such statistic counts the number of distinct <code>k[i]</code>-stars whose center node is in the second mode of the network. The second mode of a bipartite network object is sometimes known as the “event” mode. A <i>k</i>-star is defined to be a center node <i>N</i> and a set of <i>k</i> different nodes <i>{O[1], …, O[k]}</i> such that the ties <i>{N, O[i]}</i> exist for <i>i=1, …, k</i>. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified then the count is over the number of <i>k</i>-stars (with center node in the second mode) where all nodes have the same value of the attribute. This term can only be used for undirected bipartite networks. Note that <code>b2star(1)</code> is equal to <code>b1star(1)</code> and to <code>edges</code>.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_b2starmix_1">b2starmix(k, attr, base=NULL, diff=TRUE)</a><br>
<p>
<em> Mixing matrix for k-stars centered on the second mode of a bipartite network:</em> This term is exactly the same as <code>b1starmix</code> except that the roles of b1 and b2 are reversed.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_b2twostar_1">b2twostar(b1attr, b2attr, base=NULL, b1levels=NULL, b2levels=NULL, levels2=NULL)</a><br>
<p>
<em> Two-star census for central nodes centered on the second mode of a bipartite network:</em> This term is exactly the same as <code>b1twostar</code> except that the roles of b1 and b2 are reversed.
</p>
</td>
<td>
binary, bipartite, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_balance_1">balance()</a><br>
<p>
<em>Balanced triads:</em> This term adds one network statistic to the model equal to the number of triads in the network that are balanced. The balanced triads are those of type <code>102</code> or <code>300</code> in the categorization of Davis and Leinhardt (1972). For details on the 16 possible triad types, see <code>?triad.classify</code> in the <code>{sna}</code> package. For an undirected network, the balanced triads are those with an odd number of ties (i.e., 1 and 3).
</p>
</td>
<td>
binary, triad-related, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_coincidence_1">coincidence(levels=NULL,active=0)</a><br>
<p>
<em>Coincident node count for the second mode in a bipartite (aka two-mode) network:</em> By default this term adds one network statistic to the model for each pair of nodes of mode two. It is equal to the number of (first mode) mutual partners of that pair. The first mode of a bipartite network object is sometimes known as the “actor” mode and the seconds as the “event” mode. So this is the number of actors going to both events in the pair. The optional argument <code>levels</code> specifies which pairs of nodes in mode two to include (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). The second optional argument, <code>active</code>, selects pairs for which the observed count is at least <code>active</code>. If both <code>levels</code> and <code>active</code> are specified, then <code>active</code> is ignored. (Thus, indices passed as <code>levels</code> should correspond to indices when <code>levels</code> = NULL and <code>active</code> = 0.) This term can only be used with undirected bipartite networks.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
binary, bipartite, undirected
</td>
</tr>
<tr>
<td>
<a id="term_concurrent_1">concurrent(by=NULL, levels=NULL)</a><br>
<p>
<em>Concurrent node count:</em> This term adds one network statistic to the model, equal to the number of nodes in the network with degree 2 or higher. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details); it functions just like the <code>by</code> argument of the <code>degree</code> term. This term can only be used with undirected networks.
</p>
</td>
<td>
binary, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_concurrentties_1">concurrentties(by=NULL, levels=NULL)</a><br>
<p>
<em>Concurrent tie count:</em> This term adds one network statistic to the model, equal to the number of ties incident on each actor beyond the first. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details); it functions just like the <code>by</code> argument of the <code>degree</code> term. This term can only be used with undirected networks.
</p>
</td>
<td>
binary, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_ctriple_1">ctriple(attr=NULL, diff=FALSE, levels=NULL)</a><br>
<p>
<em>Cyclic triples:</em> By default, this term adds one statistic to the model, equal to the number of cyclic triples in the network, defined as a set of edges of the form <i>{(i,j), (j,k), (k,i)}</i>. Note that for all directed networks, <code>triangle</code> is equal to <code>ttriple+ctriple</code>, so at most two of these three terms can be in a model. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code>, then the statistic is the number of cyclic triples where all three nodes have the same value of the attribute. If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code>, then one statistic is added to the model for each value of <code>attr</code> (or each value of <code>attr</code> specified by <code>levels</code> if that argument is passed), equal to the number of cyclic triples where all three nodes have that value of the attribute. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_ctriad_2">ctriad()</a><br>
<p>
<em>Cyclic triples:</em> By default, this term adds one statistic to the model, equal to the number of cyclic triples in the network, defined as a set of edges of the form <i>{(i,j), (j,k), (k,i)}</i>. Note that for all directed networks, <code>triangle</code> is equal to <code>ttriple+ctriple</code>, so at most two of these three terms can be in a model. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code>, then the statistic is the number of cyclic triples where all three nodes have the same value of the attribute. If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code>, then one statistic is added to the model for each value of <code>attr</code> (or each value of <code>attr</code> specified by <code>levels</code> if that argument is passed), equal to the number of cyclic triples where all three nodes have that value of the attribute. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_cycle_1">cycle(k, semi=FALSE)</a><br>
<p>
<em>k-Cycle Census:</em> The <code>k</code> argument must be a vector of integers giving the cycle lengths to count. Directed cycle lengths may range from <code>2</code> to <code>N</code> (the network size); undirected cycle lengths and semicycle lengths may range from <code>3</code> to <code>N</code>; length 2 semicycles are not currently supported. Note that directed 2-cycles are equivalent to mutual dyads.
</p>
<p>
This term adds one network statistic to the model for each value of <code>k</code>, corresponding to the number of <code>k</code>-cycles (or, alternately, semicycles) in the graph.
</p>
<p>
The optional argument <code>semi</code> is a logical indicating whether semicycles (rather than directed cycles) should be counted; this is ignored in the undirected case.
</p>
<p>
This term can be used with either directed or undirected networks.
</p>
</td>
<td>
binary, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_cyclicalties_1">cyclicalties(attr=NULL, levels=NULL)</a><br>
<p>
<em>Cyclical ties:</em> This term adds one statistic, equal to the number of ties <i>i–&gt;j</i> such that there exists a two-path from <i>j</i> to <i>i</i>. (Related to the <code>ttriple</code> term.) The binary version takes a nodal attribute <code>attr</code>, and, if given, all three nodes involved (<i>i</i>, <i>j</i>, and the node on the two-path) must match on this attribute in order for <i>i–&gt;j</i> to be counted.
</p>
</td>
<td>
binary, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_cyclicalties_2">cyclicalties(threshold=0)</a><br>
<p>
<em>Cyclical ties:</em> This term adds one statistic, equal to the number of ties <i>i–&gt;j</i> such that there exists a two-path from <i>j</i> to <i>i</i>. (Related to the <code>ttriple</code> term.) The binary version takes a nodal attribute <code>attr</code>, and, if given, all three nodes involved (<i>i</i>, <i>j</i>, and the node on the two-path) must match on this attribute in order for <i>i–&gt;j</i> to be counted.
</p>
</td>
<td>
valued, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_cyclicalweights_1">cyclicalweights(twopath=“min”,combine=“max”,affect=“min”)</a><br>
<p>
<em>Cyclical weights:</em> This statistic implements the cyclical weights statistic, like that defined by Krivitsky (2012), Equation 13, but with the focus dyad being <i>y_{j,i}</i> rather than <i>y_{i,j}</i>. The currently implemented options for <code>twopath</code> is the minimum of the constituent dyads (<code>“min”</code>) or their geometric mean (<code>“geomean”</code>); for <code>combine</code>, the maximum of the 2-path strengths (<code>“max”</code>) or their sum (<code>“sum”</code>); and for <code>affect</code>, the minimum of the focus dyad and the combined strength of the two paths (<code>“min”</code>) or their geometric mean (<code>“geomean”</code>). For each of these options, the first (and the default) is more stable but also more conservative, while the second is more sensitive but more likely to induce a multimodal distribution of networks.
</p>
</td>
<td>
valued, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_ddsp_1">ddsp(d, type=“OTP”)</a><br>
<p>
<em>Directed dyadwise shared partners:</em> This term adds one network statistic to the model for each element in <code>d</code> where the <i>i</i>th such statistic equals the number of <em>dyads</em> in the network with exactly <code>d[i]</code> shared partners. This term can only be used with directed networks.
</p>
<p>
While there is only one shared partner configuration in the undirected case, nine distinct configurations are possible for directed graphs, selected using the <code>type</code> argument. Currently, terms may be defined with respect to five of these configurations; they are defined here as follows (using terminology from Butts (2008) and the <code>relevent</code> package):
</p>
<dl>
<dt>
Outgoing Two-path (<code>“OTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OTP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k-&gt;j</i>. Also known as “transitive shared partner”.
</p>
</dd>
<dt>
Incoming Two-path (<code>“ITP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ITP shared partner of ordered pair <i>(i,j)</i> iff <i>j-&gt;k-&gt;i</i>. Also known as “cyclical shared partner”
</p>
</dd>
<dt>
Reciprocated Two-path (<code>“RTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an RTP shared partner of ordered pair <i>(i,j)</i> iff <i>i&lt;-&gt;k&lt;-&gt;j</i>.
</p>
</dd>
<dt>
Outgoing Shared Partner (<code>“OSP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OSP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k, j-&gt;k</i>.
</p>
</dd>
<dt>
Incoming Shared Partner (<code>“ISP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ISP shared partner of ordered pair <i>(i,j)</i> iff <i>k-&gt;i, k-&gt;j</i>.
</p>
</dd>
</dl>
<p>
By default, outgoing two-paths (<code>“OTP”</code>) are calculated. Note that Robins et al. (2009) define closely related statistics to several of the above, using slightly different terminology.
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_degrange_1">degrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)</a><br>
<p>
<em>Degree range:</em> The <code>from</code> and <code>to</code> arguments are vectors of distinct integers (or <code>+Inf</code>, for <code>to</code> (its default)). If one of the vectors has length 1, it is recycled to the length of the other. Otherwise, they must have the same length. This term adds one network statistic to the model for each element of <code>from</code> (or <code>to</code>); the <i>i</i>th such statistic equals the number of nodes in the network of degree greater than or equal to <code>from[i]</code> but strictly less than <code>to[i]</code>, i.e. with edges in semiopen interval <code>[from,to)</code>. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified and <code>homophily</code> is <code>TRUE</code>, then degrees are calculated using the subnetwork consisting of only edges whose endpoints have the same value of the <code>by</code> attribute. If <code>by</code> is specified and <code>homophily</code> is <code>FALSE</code> (the default), then separate degree range statistics are calculated for nodes having each separate value of the attribute.
</p>
<p>
This term can only be used with undirected networks; for directed networks see <code>idegrange</code> and <code>odegrange</code>. This term can be used with bipartite networks, and will count nodes of both first and second mode in the specified degree range. To count only nodes of the first mode (“actors”), use <code>b1degrange</code> and to count only those fo the second mode (“events”), use <code>b2degrange</code>.
</p>
</td>
<td>
binary, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_degree_1">degree(d, by=NULL, homophily=FALSE, levels=NULL)</a><br>
<p>
<em>Degree:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of nodes in the network of degree <code>d[i]</code>, i.e. with exactly <code>d[i]</code> edges. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified and <code>homophily</code> is <code>TRUE</code>, then degrees are calculated using the subnetwork consisting of only edges whose endpoints have the same value of the <code>by</code> attribute. If <code>by</code> is specified and <code>homophily</code> is <code>FALSE</code> (the default), then separate degree statistics are calculated for nodes having each separate value of the attribute. This term can only be used with undirected networks; for directed networks see <code>idegree</code> and <code>odegree</code>.
</p>
</td>
<td>
binary, undirected, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_degree1.5_1">degree1.5()</a><br>
<p>
<em>Degree to the 3/2 power:</em> This term adds one network statistic to the model equaling the sum over the actors of each actor’s degree taken to the 3/2 power (or, equivalently, multiplied by its square root). This term is an undirected analog to the terms of Snijders et al. (2010), equations (11) and (12). This term can only be used with undirected networks.
</p>
</td>
<td>
binary, undirected
</td>
</tr>
<tr>
<td>
<a id="term_degreepopularity_1">degreepopularity()</a><br>
<p>
<em>Degree popularity (deprecated):</em> see <code>degree1.5</code>.
</p>
</td>
<td>
binary, undirected, deprecated
</td>
</tr>
<tr>
<td>
<a id="term_degcrossprod_1">degcrossprod()</a><br>
<p>
<em>Degree Cross-Product:</em> This term adds one network statistic equal to the mean of the cross-products of the degrees of all pairs of nodes in the network which are tied. Only coded for undirected networks.
</p>
</td>
<td>
binary, undirected
</td>
</tr>
<tr>
<td>
<a id="term_degcor_1">degcor()</a><br>
<p>
<em>Degree Correlation:</em> This term adds one network statistic equal to the correlation of the degrees of all pairs of nodes in the network which are tied. Only coded for undirected networks.
</p>
</td>
<td>
binary, undirected
</td>
</tr>
<tr>
<td>
<a id="term_density_1">density()</a><br>
<p>
<em>Density:</em> This term adds one network statistic equal to the density of the network. For undirected networks, <code>density</code> equals <code>kstar(1)</code> or <code>edges</code> divided by <i>n(n-1)/2</i>; for directed networks, <code>density</code> equals <code>edges</code> or <code>istar(1)</code> or <code>ostar(1)</code> divided by <i>n(n-1)</i>.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_diff_1">diff(attr, pow=1, dir=“t-h”, sign.action=“identity”)</a><br>
<p>
<em>Difference:</em> The <code>attr</code> argument specifies a quantitative vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). For values of <code>pow</code> other than <code>0</code>, this term adds one network statistic to the model, equaling the sum, over directed edges <i>(i,j)</i>, of <code>sign.action(attr[i]-attr[j])^pow</code> if <code>dir</code> is <code>“t-h”</code> (the default), <code>“tail-head”</code>, or <code>“b1-b2”</code> and of <code>sign.action(attr[j]-attr[i])^pow</code> if <code>“h-t”</code>, <code>“head-tail”</code>, or <code>“b2-b1”</code>. That is, the argument <code>dir</code> determines which vertex’s attribute is subtracted from which, with tail being the origin of a directed edge and head being its destination, and bipartite networks’ edges being treated as going from the first part (b1) to the second (b2).
</p>
<p>
If <code>pow==0</code>, the exponentiation is replaced by the signum function: <code>+1</code> if the difference is positive, <code>0</code> if there is no difference, and <code>-1</code> if the difference is negative. Note that this function is applied <em>after</em> the <code>sign.action</code>. The comparison is exact, so when using calculated values of <code>attr</code>, ensure that values that you want to be considered equal are, in fact, equal.
</p>
<p>
The following <code>sign.actions</code> are possible:
</p>
<dl>
<dt>
<code>“identity”</code> (the default)
</dt>
<dd>
<p>
no transformation of the difference regardless of sign
</p>
</dd>
<dt>
<code>“abs”</code>
</dt>
<dd>
<p>
absolute value of the difference: equivalent to the <code>absdiff</code> term
</p>
</dd>
<dt>
<code>“posonly”</code>
</dt>
<dd>
<p>
positive differences are kept, negative differences are replaced by 0
</p>
</dd>
<dt>
<code>“negonly”</code>
</dt>
<dd>
<p>
negative differences are kept, positive differences are replaced by 0
</p>
</dd>
</dl>
<p>
Note that this term may not be meaningful for unipartite undirected networks unless <code>sign.action==“abs”</code>. When used on such a network, it behaves as if all edges were directed, going from the lower-indexed vertex to the higher-indexed vertex.
</p>
</td>
<td>
binary, dyad-independent, frequently-used, directed, undirected, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_diff_2">diff(attr, pow=1, dir=“t-h”, sign.action=“identity”, form =“sum”)</a><br>
<p>
<em>Difference:</em> The <code>attr</code> argument specifies a quantitative vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). For values of <code>pow</code> other than <code>0</code>, this term adds one network statistic to the model, equaling the sum, over directed edges <i>(i,j)</i>, of <code>sign.action(attr[i]-attr[j])^pow</code> if <code>dir</code> is <code>“t-h”</code> (the default), <code>“tail-head”</code>, or <code>“b1-b2”</code> and of <code>sign.action(attr[j]-attr[i])^pow</code> if <code>“h-t”</code>, <code>“head-tail”</code>, or <code>“b2-b1”</code>. That is, the argument <code>dir</code> determines which vertex’s attribute is subtracted from which, with tail being the origin of a directed edge and head being its destination, and bipartite networks’ edges being treated as going from the first part (b1) to the second (b2).
</p>
<p>
If <code>pow==0</code>, the exponentiation is replaced by the signum function: <code>+1</code> if the difference is positive, <code>0</code> if there is no difference, and <code>-1</code> if the difference is negative. Note that this function is applied <em>after</em> the <code>sign.action</code>. The comparison is exact, so when using calculated values of <code>attr</code>, ensure that values that you want to be considered equal are, in fact, equal.
</p>
<p>
The following <code>sign.actions</code> are possible:
</p>
<dl>
<dt>
<code>“identity”</code> (the default)
</dt>
<dd>
<p>
no transformation of the difference regardless of sign
</p>
</dd>
<dt>
<code>“abs”</code>
</dt>
<dd>
<p>
absolute value of the difference: equivalent to the <code>absdiff</code> term
</p>
</dd>
<dt>
<code>“posonly”</code>
</dt>
<dd>
<p>
positive differences are kept, negative differences are replaced by 0
</p>
</dd>
<dt>
<code>“negonly”</code>
</dt>
<dd>
<p>
negative differences are kept, positive differences are replaced by 0
</p>
</dd>
</dl>
<p>
Note that this term may not be meaningful for unipartite undirected networks unless <code>sign.action==“abs”</code>. When used on such a network, it behaves as if all edges were directed, going from the lower-indexed vertex to the higher-indexed vertex.
</p>
</td>
<td>
valued, dyad-independent, directed, undirected, bipartite, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_desp_1">desp(d, type=“OTP”)</a><br>
<p>
<em>Directed edgewise shared partners:</em> This term adds one network statistic to the model for each element in <code>d</code> where the <i>i</i>th such statistic equals the number of <em>edges</em> in the network with exactly <code>d[i]</code> shared partners. This term can only be used with directed networks.
</p>
<p>
While there is only one shared partner configuration in the undirected case, nine distinct configurations are possible for directed graphs, selected using the <code>type</code> argument. Currently, terms may be defined with respect to five of these configurations; they are defined here as follows (using terminology from Butts (2008) and the <code>relevent</code> package):
</p>
<dl>
<dt>
Outgoing Two-path (<code>“OTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OTP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k-&gt;j</i>. Also known as “transitive shared partner”.
</p>
</dd>
<dt>
Incoming Two-path (<code>“ITP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ITP shared partner of ordered pair <i>(i,j)</i> iff <i>j-&gt;k-&gt;i</i>. Also known as “cyclical shared partner”
</p>
</dd>
<dt>
Reciprocated Two-path (<code>“RTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an RTP shared partner of ordered pair <i>(i,j)</i> iff <i>i&lt;-&gt;k&lt;-&gt;j</i>.
</p>
</dd>
<dt>
Outgoing Shared Partner (<code>“OSP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OSP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k, j-&gt;k</i>.
</p>
</dd>
<dt>
Incoming Shared Partner (<code>“ISP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ISP shared partner of ordered pair <i>(i,j)</i> iff <i>k-&gt;i, k-&gt;j</i>.
</p>
</dd>
</dl>
<p>
By default, outgoing two-paths (<code>“OTP”</code>) are calculated. Note that Robins et al. (2009) define closely related statistics to several of the above, using slightly different terminology.
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_dgwdsp_1">dgwdsp(decay, fixed=FALSE, cutoff=30, type=“OTP”)</a><br>
<p>
<em>Geometrically weighted dyadwise shared partner distribution:</em> This term adds one network statistic to the model equal to the geometrically weighted dyadwise shared partner distribution with decay parameter <code>decay</code> parameter, which should be non-negative. (this parameter was called <code>alpha</code> prior to <code>ergm 3.7</code>). The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006). Note that the GWDSP statistic is equal to the sum of GWNSP plus GWESP.
</p>
<p>
While there is only one shared partner configuration in the undirected case, nine distinct configurations are possible for directed graphs, selected using the <code>type</code> argument. Currently, terms may be defined with respect to five of these configurations; they are defined here as follows (using terminology from Butts (2008) and the <code>relevent</code> package):
</p>
<dl>
<dt>
Outgoing Two-path (<code>“OTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OTP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k-&gt;j</i>. Also known as “transitive shared partner”.
</p>
</dd>
<dt>
Incoming Two-path (<code>“ITP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ITP shared partner of ordered pair <i>(i,j)</i> iff <i>j-&gt;k-&gt;i</i>. Also known as “cyclical shared partner”
</p>
</dd>
<dt>
Reciprocated Two-path (<code>“RTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an RTP shared partner of ordered pair <i>(i,j)</i> iff <i>i&lt;-&gt;k&lt;-&gt;j</i>.
</p>
</dd>
<dt>
Outgoing Shared Partner (<code>“OSP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OSP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k, j-&gt;k</i>.
</p>
</dd>
<dt>
Incoming Shared Partner (<code>“ISP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ISP shared partner of ordered pair <i>(i,j)</i> iff <i>k-&gt;i, k-&gt;j</i>.
</p>
</dd>
</dl>
<p>
By default, outgoing two-paths (<code>“OTP”</code>) are calculated. Note that Robins et al. (2009) define closely related statistics to several of the above, using slightly different terminology.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying DSP terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_dgwesp_1">dgwesp(decay, fixed=FALSE, cutoff=30, type=“OTP”)</a><br>
<p>
<em>Geometrically weighted edgewise shared partner distribution:</em> This term adds a statistic equal to the geometrically weighted <em>edgewise</em> (not dyadwise) shared partner distribution with decay parameter <code>decay</code> parameter, which should be non-negative. (this parameter was called <code>alpha</code> prior to <code>ergm 3.7</code>). The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006).
</p>
<p>
While there is only one shared partner configuration in the undirected case, nine distinct configurations are possible for directed graphs, selected using the <code>type</code> argument. Currently, terms may be defined with respect to five of these configurations; they are defined here as follows (using terminology from Butts (2008) and the <code>relevent</code> package):
</p>
<dl>
<dt>
Outgoing Two-path (<code>“OTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OTP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k-&gt;j</i>. Also known as “transitive shared partner”.
</p>
</dd>
<dt>
Incoming Two-path (<code>“ITP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ITP shared partner of ordered pair <i>(i,j)</i> iff <i>j-&gt;k-&gt;i</i>. Also known as “cyclical shared partner”
</p>
</dd>
<dt>
Reciprocated Two-path (<code>“RTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an RTP shared partner of ordered pair <i>(i,j)</i> iff <i>i&lt;-&gt;k&lt;-&gt;j</i>.
</p>
</dd>
<dt>
Outgoing Shared Partner (<code>“OSP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OSP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k, j-&gt;k</i>.
</p>
</dd>
<dt>
Incoming Shared Partner (<code>“ISP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ISP shared partner of ordered pair <i>(i,j)</i> iff <i>k-&gt;i, k-&gt;j</i>.
</p>
</dd>
</dl>
<p>
By default, outgoing two-paths (<code>“OTP”</code>) are calculated. Note that Robins et al. (2009) define closely related statistics to several of the above, using slightly different terminology.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying ESP terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_dgwnsp_1">dgwnsp(decay, fixed=FALSE, cutoff=30, type=“OTP”)</a><br>
<p>
<em>Geometrically weighted non-edgewise shared partner distribution:</em> This term is just like gwesp and gwdsp except it adds a statistic equal to the geometrically weighted nonedgewise (that is, over dyads that do not have an edge) shared partner distribution with decay parameter <code>decay</code> parameter, which should be non-negative. (this parameter was called <code>alpha</code> prior to <code>ergm 3.7</code>). The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006).
</p>
<p>
While there is only one shared partner configuration in the undirected case, nine distinct configurations are possible for directed graphs, selected using the <code>type</code> argument. Currently, terms may be defined with respect to five of these configurations; they are defined here as follows (using terminology from Butts (2008) and the <code>relevent</code> package):
</p>
<dl>
<dt>
Outgoing Two-path (<code>“OTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OTP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k-&gt;j</i>. Also known as “transitive shared partner”.
</p>
</dd>
<dt>
Incoming Two-path (<code>“ITP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ITP shared partner of ordered pair <i>(i,j)</i> iff <i>j-&gt;k-&gt;i</i>. Also known as “cyclical shared partner”
</p>
</dd>
<dt>
Reciprocated Two-path (<code>“RTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an RTP shared partner of ordered pair <i>(i,j)</i> iff <i>i&lt;-&gt;k&lt;-&gt;j</i>.
</p>
</dd>
<dt>
Outgoing Shared Partner (<code>“OSP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OSP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k, j-&gt;k</i>.
</p>
</dd>
<dt>
Incoming Shared Partner (<code>“ISP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ISP shared partner of ordered pair <i>(i,j)</i> iff <i>k-&gt;i, k-&gt;j</i>.
</p>
</dd>
</dl>
<p>
By default, outgoing two-paths (<code>“OTP”</code>) are calculated. Note that Robins et al. (2009) define closely related statistics to several of the above, using slightly different terminology.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying NSP terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_dnsp_1">dnsp(d, type=“OTP”)</a><br>
<p>
<em>Directed non-edgewise shared partners:</em> This term adds one network statistic to the model for each element in <code>d</code> where the <i>i</i>th such statistic equals the number of <em>non-edges</em> in the network with exactly <code>d[i]</code> shared partners. This term can only be used with directed networks.
</p>
<p>
While there is only one shared partner configuration in the undirected case, nine distinct configurations are possible for directed graphs, selected using the <code>type</code> argument. Currently, terms may be defined with respect to five of these configurations; they are defined here as follows (using terminology from Butts (2008) and the <code>relevent</code> package):
</p>
<dl>
<dt>
Outgoing Two-path (<code>“OTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OTP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k-&gt;j</i>. Also known as “transitive shared partner”.
</p>
</dd>
<dt>
Incoming Two-path (<code>“ITP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ITP shared partner of ordered pair <i>(i,j)</i> iff <i>j-&gt;k-&gt;i</i>. Also known as “cyclical shared partner”
</p>
</dd>
<dt>
Reciprocated Two-path (<code>“RTP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an RTP shared partner of ordered pair <i>(i,j)</i> iff <i>i&lt;-&gt;k&lt;-&gt;j</i>.
</p>
</dd>
<dt>
Outgoing Shared Partner (<code>“OSP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an OSP shared partner of ordered pair <i>(i,j)</i> iff <i>i-&gt;k, j-&gt;k</i>.
</p>
</dd>
<dt>
Incoming Shared Partner (<code>“ISP”</code>)
</dt>
<dd>
<p>
vertex <i>k</i> is an ISP shared partner of ordered pair <i>(i,j)</i> iff <i>k-&gt;i, k-&gt;j</i>.
</p>
</dd>
</dl>
<p>
By default, outgoing two-paths (<code>“OTP”</code>) are calculated. Note that Robins et al. (2009) define closely related statistics to several of the above, using slightly different terminology.
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_dsp_1">dsp(d)</a><br>
<p>
<em>Dyadwise shared partners:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of dyads in the network with exactly <code>d[i]</code> shared partners. This term can be used with directed and undirected networks.
</p>
<p>
For directed networks, only outgoing two-path (“OTP”) shared partners are counted. In other words, for a (directed) dyad <code>(i,j)</code> in a directed graph, the number of shared partners counted by <code>dsp</code> is the number of nodes <code>k</code> that have edges <code>i -&gt; k -&gt; j</code>. (These may also be called homogeneous shared partners.) To count other types of shared partners instead, see <code>ddsp</code>.
</p>
</td>
<td>
binary, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_dyadcov_1">dyadcov(x, attrname=NULL)</a><br>
<p>
<em>Dyadic covariate:</em> The <code>x</code> argument is either a square matrix of covariates, one for each possible edge in the network, the name of a network attribute of covariates, or a network; if the latter, optional argument <code>attrname</code> provides the name of the quantitative edge attribute to use for covariate values (in this case, missing edges in <code>x</code> are assigned a covariate value of zero). This term adds three statistics to the model, each equal to the sum of the covariate values for all dyads occupying one of the three possible non-empty dyad states (mutual, upper-triangular asymmetric, and lower-triangular asymmetric dyads, respectively), with the empty or null state serving as a reference category. If the network is undirected, <code>x</code> is either a matrix of edgewise covariates, or a network; if the latter, optional argument <code>attrname</code> provides the name of the edge attribute to use for edge values. This term adds one statistic to the model, equal to the sum of the covariate values for each edge appearing in the network. The <code>edgecov</code> and <code>dyadcov</code> terms are equivalent for undirected networks.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_edgecov_1">edgecov(x, attrname=NULL)</a><br>
<p>
<em>Edge covariate:</em> The <code>x</code> argument is either a square matrix of covariates, one for each possible edge in the network, the name of a network attribute of covariates, or a network; if the latter, optional argument <code>attrname</code> provides the name of the quantitative edge attribute to use for covariate values (in this case, missing edges in <code>x</code> are assigned a covariate value of zero). This term adds one statistic to the model, equal to the sum of the covariate values for each edge appearing in the network. The <code>edgecov</code> term applies to both directed and undirected networks. For undirected networks the covariates are also assumed to be undirected. The <code>edgecov</code> and <code>dyadcov</code> terms are equivalent for undirected networks.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_edgecov_2">edgecov(x,)</a><br>
<p>
<em>Edge covariate:</em> The <code>x</code> argument is either a square matrix of covariates, one for each possible edge in the network, the name of a network attribute of covariates, or a network; if the latter, optional argument <code>attrname</code> provides the name of the quantitative edge attribute to use for covariate values (in this case, missing edges in <code>x</code> are assigned a covariate value of zero). This term adds one statistic to the model, equal to the sum of the covariate values for each edge appearing in the network. The <code>edgecov</code> term applies to both directed and undirected networks. For undirected networks the covariates are also assumed to be undirected. The <code>edgecov</code> and <code>dyadcov</code> terms are equivalent for undirected networks.
</p>
</td>
<td>
valued, directed, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_edges_1">edges()</a><br>
<p>
<em>Edges:</em> This term adds one network statistic equal to the number of edges (i.e. nonzero values) in the network. For undirected networks, <code>edges</code> is equal to <code>kstar(1)</code>; for directed networks, <code>edges</code> is equal to both <code>ostar(1)</code> and <code>istar(1)</code>.
</p>
</td>
<td>
binary, valued, dyad-independent, directed, undirected, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_nonzero_2">nonzero()</a><br>
<p>
<em>Edges:</em> This term adds one network statistic equal to the number of edges (i.e. nonzero values) in the network. For undirected networks, <code>edges</code> is equal to <code>kstar(1)</code>; for directed networks, <code>edges</code> is equal to both <code>ostar(1)</code> and <code>istar(1)</code>.
</p>
</td>
<td>
valued, directed, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_esp_1">esp(d)</a><br>
<p>
<em>Edgewise shared partners:</em> This is just like the <code>dsp</code> term, except this term adds one network statistic to the model for each element in <code>d</code> where the <i>i</i>th such statistic equals the number of <em>edges</em> (rather than dyads) in the network with exactly <code>d[i]</code> shared partners. This term can be used with directed and undirected networks.
</p>
<p>
For directed networks, only outgoing two-path (“OTP”) shared partners are counted. In other words, for a (directed) edge <code>i -&gt; j</code> in a directed graph, the number of shared partners counted by <code>esp</code> is the number of nodes <code>k</code> that have edges <code>i -&gt; k -&gt; j</code>. (These may also be called homogeneous shared partners.) To count other types of shared partners instead, see <code>desp</code>.
</p>
</td>
<td>
binary, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_equalto_1">equalto(value=0, tolerance=0)</a><br>
<p>
<em>Number of dyads with values equal to a specific value (within tolerance):</em> Adds one statistic equal to the number of dyads whose values are within <code>tolerance</code> of <code>value</code>, i.e., between <code>value-tolerance</code> and <code>value+tolerance</code>, inclusive.
</p>
</td>
<td>
valued, directed, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_greaterthan_1">greaterthan(threshold=0)</a><br>
<p>
<em>Number of dyads with values strictly greater than a threshold:</em> Adds the number of statistics equal to the length of <code>threshold</code> equaling to the number of dyads whose values exceed the corresponding element of <code>threshold</code>.
</p>
</td>
<td>
valued, directed, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_gwb1degree_1">gwb1degree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)</a><br>
<p>
<em>Geometrically weighted degree distribution for the first mode in a bipartite (aka two-mode) network:</em> This term adds one network statistic to the model equal to the weighted degree distribution with decay controlled by the <code>decay</code> parameter, which should be non-negative, for nodes in the first mode of a bipartite network. The first mode of a bipartite network object is sometimes known as the “actor” mode. The <code>decay</code> parameter is the same as theta_s in equation (14) in Hunter (2007). The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used as merely the starting value for the estimation in a curved exponential family model (the default).
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying degree terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
<p>
If <code>attr</code> is specified (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details) then separate degree statistics are calculated for nodes having each separate value of the attribute. This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, curved
</td>
</tr>
<tr>
<td>
<a id="term_gwb1dsp_1">gwb1dsp(decay=0, fixed=FALSE, cutoff=30)</a><br>
<p>
<em>Geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition:</em> This term adds one network statistic to the model equal to the geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition, with decay parameter <code>decay</code> parameter, which should be non-negative. The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006). This term can only be used with bipartite networks.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying b1dsp terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
</td>
<td>
binary, bipartite, undirected, curved
</td>
</tr>
<tr>
<td>
<a id="term_gwb2degree_1">gwb2degree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)</a><br>
<p>
<em>Geometrically weighted degree distribution for the second mode in a bipartite (aka two-mode) network:</em> This term adds one network statistic to the model equal to the weighted degree distribution with decay controlled by the which should be non-negative, for nodes in the second mode of a bipartite network. The second mode of a bipartite network object is sometimes known as the “event” mode. The <code>decay</code> parameter is the same as theta_s in equation (14) in Hunter (2007). The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used as merely the starting value for the estimation in a curved exponential family model (the default).
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying degree terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
<p>
If <code>attr</code> is specified (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details) then separate degree statistics are calculated for nodes having each separate value of the attribute. This term can only be used with undirected bipartite networks.
</p>
</td>
<td>
binary, bipartite, undirected, curved
</td>
</tr>
<tr>
<td>
<a id="term_gwb2dsp_1">gwb2dsp(decay=0, fixed=FALSE, cutoff=30)</a><br>
<p>
<em>Geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition:</em> This term adds one network statistic to the model equal to the geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition, with decay parameter <code>decay</code> parameter, which should be non-negative. The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006). This term can only be used with bipartite networks.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying b2dsp terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
</td>
<td>
binary, bipartite, undirected, curved
</td>
</tr>
<tr>
<td>
<a id="term_gwdegree_1">gwdegree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)</a><br>
<p>
<em>Geometrically weighted degree distribution:</em> This term adds one network statistic to the model equal to the weighted degree distribution with decay controlled by the <code>decay</code> parameter. The <code>decay</code> parameter is the same as theta_s in equation (14) in Hunter (2007). The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006).
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying degree terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
<p>
If <code>attr</code> is specified (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details) then separate degree statistics are calculated for nodes having each separate value of the attribute. This term can only be used with undirected networks.
</p>
</td>
<td>
binary, undirected, curved, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_gwdsp_1">gwdsp(decay, fixed=FALSE, cutoff=30)</a><br>
<p>
<em>Geometrically weighted dyadwise shared partner distribution:</em> This term adds one network statistic to the model equal to the geometrically weighted dyadwise shared partner distribution with decay parameter <code>decay</code> parameter, which should be non-negative. The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006). This term can be used with directed and undirected networks.
</p>
<p>
For directed networks, only outgoing two-path (“OTP”) shared partners are counted. In other words, for a (directed) dyad <code>(i,j)</code> in a directed graph, the number of shared partners counted by <code>gwdsp</code> is the number of nodes <code>k</code> that have edges <code>i -&gt; k -&gt; j</code>. (These may also be called homogeneous shared partners.) To count other types of shared partners instead, see <code>dgwdsp</code>.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying DSP terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
</td>
<td>
binary, directed, undirected, curved
</td>
</tr>
<tr>
<td>
<a id="term_gwesp_1">gwesp(decay, fixed=FALSE, cutoff=30)</a><br>
<p>
<em>Geometrically weighted edgewise shared partner distribution:</em> This term is just like <code>gwdsp</code> except it adds a statistic equal to the geometrically weighted <em>edgewise</em> (not dyadwise) shared partner distribution with decay parameter <code>decay</code> parameter, which should be non-negative. The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006). This term can be used with directed and undirected networks.
</p>
<p>
For directed networks, only outgoing two-path (“OTP”) shared partners are counted. In other words, for a (directed) edge <code>i -&gt; j</code> in a directed graph, the number of shared partners counted by <code>gwesp</code> is the number of nodes <code>k</code> that have edges <code>i -&gt; k -&gt; j</code>. (These may also be called homogeneous shared partners.) To count other types of shared partners instead, see <code>dgwesp</code>.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying ESP terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
</td>
<td>
binary, frequently-used, directed, undirected, curved
</td>
</tr>
<tr>
<td>
<a id="term_gwidegree_1">gwidegree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)</a><br>
<p>
<em>Geometrically weighted in-degree distribution:</em> This term adds one network statistic to the model equal to the weighted in-degree distribution with decay parameter <code>decay</code> parameter, which should be non-negative. (this parameter was called <code>alpha</code> prior to <code>ergm 3.7</code>). The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006). This term can only be used with directed networks.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying degree terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
<p>
If <code>attr</code> is specified (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details) then separate degree statistics are calculated for nodes having each separate value of the attribute.
</p>
</td>
<td>
binary, directed, curved
</td>
</tr>
<tr>
<td>
<a id="term_gwnsp_1">gwnsp(decay, fixed=FALSE, cutoff=30)</a><br>
<p>
<em>Geometrically weighted nonedgewise shared partner distribution:</em> This term is just like <code>gwesp</code> and <code>gwdsp</code> except it adds a statistic equal to the geometrically weighted <em>nonedgewise</em> (that is, over dyads that do not have an edge) shared partner distribution with weight parameter <code>decay</code> parameter, which should be non-negative. (this parameter was called <code>alpha</code> prior to <code>ergm 3.7</code>). The optional argument <code>fixed</code> indicates whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved exponential-family model (see Hunter and Handcock, 2006). The default is <code>FALSE</code>, which means the scale parameter is not fixed and thus the model is a CEF model. This term can be used with directed and undirected networks.
</p>
<p>
For directed networks, only outgoing two-path (“OTP”) shared partners are counted. In other words, for a (directed) non-edge <code>(i,j)</code> in a directed graph, the number of shared partners counted by <code>gwnsp</code> is the number of nodes <code>k</code> that have edges <code>i -&gt; k -&gt; j</code>. (These may also be called homogeneous shared partners.) To count other types of shared partners instead, see <code>dgwnsp</code>.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying NSP terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
</td>
<td>
binary, directed, undirected, curved
</td>
</tr>
<tr>
<td>
<a id="term_gwodegree_1">gwodegree(decay, fixed=FALSE, attr=NULL, cutoff=30, levels=NULL)</a><br>
<p>
<em>Geometrically weighted out-degree distribution:</em> This term adds one network statistic to the model equal to the weighted out-degree distribution with decay parameter <code>decay</code> parameter, which should be non-negative. (this parameter was called <code>alpha</code> prior to <code>ergm 3.7</code>). The value supplied for this parameter may be fixed (if <code>fixed=TRUE</code>), or it may be used instead as the starting value for the estimation of <code>decay</code> in a curved exponential family model (when <code>fixed=FALSE</code>, the default) (see Hunter and Handcock, 2006). This term can only be used with directed networks.
</p>
<p>
The optional argument <code>cutoff</code> sets the number of underlying degree terms to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce the computational burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code>control.ergm</code>.)
</p>
<p>
If <code>attr</code> is specified (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details) then separate degree statistics are calculated for nodes having each separate value of the attribute.
</p>
</td>
<td>
binary, directed, curved
</td>
</tr>
<tr>
<td>
<a id="term_hamming_1">hamming(x, cov, attrname=NULL)</a><br>
<p>
<em>Hamming distance:</em> This term adds one statistic to the model equal to the weighted or unweighted Hamming distance of the network from the network specified by <code>x</code>. (If no argument is given, <code>x</code> is taken to be the observed network, i.e., the network on the left side of the <i>~</i> in the formula that defines the ERGM.) Unweighted Hamming distance is defined as the total number of pairs <i>(i,j)</i> (ordered or unordered, depending on whether the network is directed or undirected) on which the two networks differ. If the optional argument <code>cov</code> is specified, then the weighted Hamming distance is computed instead, where each pair <i>(i,j)</i> contributes a pre-specified weight toward the distance when the two networks differ on that pair. The argument <code>cov</code> is either a matrix of edgewise weights or a network; if the latter, the optional argument <code>attrname</code> provides the name of the edge attribute to use for weight values.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_idegrange_1">idegrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)</a><br>
<p>
<em>In-degree range:</em> The <code>from</code> and <code>to</code> arguments are vectors of distinct integers (or <code>+Inf</code>, for <code>to</code> (its default)). If one of the vectors has length 1, it is recycled to the length of the other. Otherwise, they must have the same length. This term adds one network statistic to the model for each element of <code>from</code> (or <code>to</code>); the <i>i</i>th such statistic equals the number of nodes in the network of in-degree greater than or equal to <code>from[i]</code> but strictly less than <code>to[i]</code>, i.e. with in-edge count in semiopen interval <code>[from,to)</code>. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified and <code>homophily</code> is <code>TRUE</code>, then degrees are calculated using the subnetwork consisting of only edges whose endpoints have the same value of the <code>by</code> attribute. If <code>by</code> is specified and <code>homophily</code> is <code>FALSE</code> (the default), then separate degree range statistics are calculated for nodes having each separate value of the attribute.
</p>
<p>
This term can only be used with directed networks; for undirected networks (bipartite and not) see <code>degrange</code>. For degrees of specific modes of bipartite networks, see <code>b1degrange</code> and <code>b2degrange</code>. For in-degrees, see <code>idegrange</code>.
</p>
</td>
<td>
binary, directed, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_idegree_1">idegree(d, by=NULL, homophily=FALSE, levels=NULL)</a><br>
<p>
<em>In-degree:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of nodes in the network of in-degree <code>d[i]</code>, i.e. the number of nodes with exactly <code>d[i]</code> in-edges. The optional term <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified and <code>homophily</code> is <code>TRUE</code>, then degrees are calculated using the subnetwork consisting of only edges whose endpoints have the same value of the <code>by</code> attribute. If <code>by</code> is specified and <code>homophily</code> is <code>FALSE</code> (the default), then separate degree statistics are calculated for nodes having each separate value of the attribute. This term can only be used with directed networks; for undirected networks see <code>degree</code>.
</p>
</td>
<td>
binary, directed, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_idegree1.5_1">idegree1.5()</a><br>
<p>
<em>In-degree to the 3/2 power:</em> This term adds one network statistic to the model equaling the sum over the actors of each actor’s indegree taken to the 3/2 power (or, equivalently, multiplied by its square root). This term is analogous to the term of Snijders et al. (2010), equation (12). This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_idegreepopularity_1">idegreepopularity()</a><br>
<p>
<em>In-degree popularity (deprecated):</em> see <code>idegree1.5</code>.
</p>
</td>
<td>
binary, directed, deprecated
</td>
</tr>
<tr>
<td>
<a id="term_ininterval_1">ininterval(lower=-Inf, upper=+Inf, open=)</a><br>
<p>
<em>Number of dyads whose values are in an interval</em> Adds one statistic equaling to the number of dyads whose values are between <code>lower</code> and <code>upper</code>. Argument <code>open</code> is a <code>logical</code> vector of length 2 that controls whether the interval is open (exclusive) on the lower and on the upper end, respectively. <code>open</code> can also be specified as one of <code>“[]”</code>, <code>“(]”</code>, <code>“[)”</code>, and <code>“()”</code>.
</p>
</td>
<td>
valued, directed, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_intransitive_1">intransitive()</a><br>
<p>
<em>Intransitive triads:</em> This term adds one statistic to the model, equal to the number of triads in the network that are intransitive. The intransitive triads are those of type <code>111D</code>, <code>201</code>, <code>111U</code>, <code>021C</code>, or <code>030C</code> in the categorization of Davis and Leinhardt (1972). For details on the 16 possible triad types, see <code>triad.classify</code> in the <code>sna</code> package. Note the distinction from the <code>ctriple</code> term. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_intransitive_1">intransitive()</a><br>
<p>
<em>Intransitive triads:</em> This term adds one statistic to the model, equal to the number of triads in the network that are intransitive. The intransitive triads are those of type <code>111D</code>, <code>201</code>, <code>111U</code>, <code>021C</code>, or <code>030C</code> in the categorization of Davis and Leinhardt (1972). For details on the 16 possible triad types, see <code>triad.classify</code> in the <code>sna</code> package. Note the distinction from the <code>ctriple</code> term. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_isolatededges_1">isolatededges()</a><br>
<p>
<em>Isolated edges:</em> This term adds one statistic to the model equal to the number of isolated edges in the network, i.e., the number of edges each of whose endpoints has degree 1. This term can only be used with undirected networks.
</p>
</td>
<td>
binary, undirected, bipartite
</td>
</tr>
<tr>
<td>
<a id="term_isolates_1">isolates()</a><br>
<p>
<em>Isolates:</em> This term adds one statistic to the model equal to the number of isolates in the network. For an undirected network, an isolate is defined to be any node with degree zero. For a directed network, an isolate is any node with both in-degree and out-degree equal to zero.
</p>
</td>
<td>
binary, directed, undirected, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_istar_1">istar(k, attr=NULL, levels=NULL)</a><br>
<p>
<em>In-stars:</em> The <code>k</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>k</code>. The <i>i</i>th such statistic counts the number of distinct <code>k[i]</code>-instars in the network, where a <i>k</i>-instar is defined to be a node <i>N</i> and a set of <i>k</i> different nodes <i>{O[1], …, O[k]}</i> such that the ties <i>(O_j, N)</i> exist for <i>j=1, …, k</i>. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified then the count is over the number of <i>k</i>-instars where all nodes have the same value of the attribute. This term can only be used for directed networks; for undirected networks see <code>kstar</code>. Note that <code>istar(1)</code> is equal to both <code>ostar(1)</code> and <code>edges</code>.
</p>
</td>
<td>
binary, directed, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_kstar_1">kstar(k, attr=NULL, levels=NULL)</a><br>
<p>
<em>k-Stars:</em> The <code>k</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>k</code>. The <i>i</i>th such statistic counts the number of distinct <code>k[i]</code>-stars in the network, where a <i>k</i>-star is defined to be a node <i>N</i> and a set of <i>k</i> different nodes <i>{O[1], …, O[k]}</i> such that the ties <i>{N, O[i]}</i> exist for <i>i=1, …, k</i>. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified then the count is over the number of <i>k</i>-stars where all nodes have the same value of the attribute. This term can only be used for undirected networks; for directed networks, see <code>istar</code>, <code>ostar</code>, <code>twopath</code> and <code>m2star</code>. Note that <code>kstar(1)</code> is equal to <code>edges</code>.
</p>
</td>
<td>
binary, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_smallerthan_1">smallerthan(threshold=0)</a><br>
<p>
<em>Number of dyads with values strictly smaller than a threshold:</em> Adds the number of statistics equal to the length of <code>threshold</code> equaling to the number of dyads whose values are exceeded by the corresponding element of <code>threshold</code>.
</p>
</td>
<td>
valued, directed, undirected, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_localtriangle_1">localtriangle(x)</a><br>
<p>
<em>Triangles within neighborhoods:</em> This term adds one statistic to the model equal to the number of triangles in the network between nodes “close to” each other. For an undirected network, a local triangle is defined to be any set of three edges between nodal pairs <i>{(i,j), (j,k), (k,i)}</i> that are in the same neighborhood. For a directed network, a triangle is defined as any set of three edges <i>(i,j), (j,k)</i> and either <i>(k{}i)</i> or <i>(k{≤ftarrow}i)</i> where again all nodes are within the same neighborhood. The argument <code>x</code> is an undirected network or an symmetric adjacency matrix that specifies whether the two nodes are in the same neighborhood. Note that <code>triangle</code>, with or without an argument, is a special case of <code>localtriangle</code>.
</p>
</td>
<td>
binary, triad-related, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_m2star_1">m2star()</a><br>
<p>
<em>Mixed 2-stars, a.k.a 2-paths:</em> This term adds one statistic to the model, equal to the number of mixed 2-stars in the network, where a mixed 2-star is a pair of distinct edges <i>(i,j), (j,k)</i>. A mixed 2-star is sometimes called a 2-path because it is a directed path of length 2 from <i>i</i> to <i>k</i> via <i>j</i>. However, in the case of a 2-path the focus is usually on the endpoints <i>i</i> and <i>k</i>, whereas for a mixed 2-star the focus is usually on the midpoint <i>j</i>. This term can only be used with directed networks; for undirected networks see <code>kstar(2)</code>. See also <code>twopath</code>.
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_meandeg_1">meandeg()</a><br>
<p>
<em>Mean vertex degree:</em> This term adds one network statistic to the model equal to the average degree of a node. Note that this term is a constant multiple of both <code>edges</code> and <code>density</code>.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_mm_1">mm(attrs, levels=NULL, levels2=-1)</a><br>
<p>
<em>Mixing matrix cells and margins:</em> <code>attrs</code> is a two-sided formula whose LHS gives the attribute or attribute function (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>)) for the rows of the mixing matrix and whose RHS gives that for its columns. A one-sided formula (e.g., <code>~A</code>) is symmetrized (e.g., <code>A~A</code>). <code>levels</code> similarly specifies the subset of rows and columns to be used. <code>levels2</code> can then be used to filter which specific cells of the matrix to include. A two-sided formula with a dot on one side calculates the margins of the mixing matrix, analogously to <code>nodefactor</code>, with <code>A~.</code> calculating the row/sender/b1 margins and <code>.~A</code> calculating the column/receiver/b2 margins.
</p>
</td>
<td>
binary, dyad-independent, frequently-used, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_mm_2">mm(attrs, levels=NULL, levels2=-1, form=“sum”)</a><br>
<p>
<em>Mixing matrix cells and margins:</em> <code>attrs</code> is a two-sided formula whose LHS gives the attribute or attribute function (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>)) for the rows of the mixing matrix and whose RHS gives that for its columns. A one-sided formula (e.g., <code>~A</code>) is symmetrized (e.g., <code>A~A</code>). <code>levels</code> similarly specifies the subset of rows and columns to be used. <code>levels2</code> can then be used to filter which specific cells of the matrix to include. A two-sided formula with a dot on one side calculates the margins of the mixing matrix, analogously to <code>nodefactor</code>, with <code>A~.</code> calculating the row/sender/b1 margins and <code>.~A</code> calculating the column/receiver/b2 margins.
</p>
</td>
<td>
valued, dyad-independent, frequently-used, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_mutual_1">mutual(same=NULL, by=NULL, diff=FALSE, keep=NULL, levels=NULL)</a><br>
<p>
<em>Mutuality:</em> In binary ERGMs, equal to the number of pairs of actors <i>i</i> and <i>j</i> for which <i>(i,j)</i> and <i>(j,i)</i> both exist. For valued ERGMs, equal to <i>∑<em>{i&lt;j} m(y</em>{i,j},y_{j,i})</i>, where <i>m</i> is determined by <code>form</code> argument: <code>“min”</code> for <i>(y_{i,j},y_{j,i})</i>, <code>“nabsdiff”</code> for <i>-|y_{i,j},y_{j,i}|</i>, <code>“product”</code> for <i>y_{i,j}y_{j,i}</i>, and <code>“geometric”</code> for <i>√{y_{i,j}}√{y_{j,i}}</i>. See Krivitsky (2012) for a discussion of these statistics. <code>form=“threshold”</code> simply computes the binary <code>mutuality</code> after thresholding at <code>threshold</code>.
</p>
<p>
This term can only be used with directed networks. The binary version also has the following capabilities: if the optional <code>same</code> argument is passed (see Specifying Vertex Attributes and Levels for details), only mutual pairs that match on the attribute are counted; separate counts for each unique matching value can be obtained by using <code>diff=TRUE</code> with <code>same</code>; and if <code>by</code> is passed (again, see Specifying Vertex Attributes and Levels), then each node is counted separately for each mutual pair in which it occurs and the counts are tabulated by unique values of the attribute. This means that the sum of the mutual statistics when <code>by</code> is used will equal twice the standard mutual statistic. Only one of <code>same</code> or <code>by</code> may be used, and only the former is affected by <code>diff</code>; if both <code>same</code> and <code>by</code> are passed, <code>by</code> is ignored. Finally, if <code>levels</code> is passed, this tells which statistics should be kept whenever the <code>mutual</code> term would ordinarily result in multiple statistics (see Specifying Vertex Attributes and Levels).
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>.
</p>
</td>
<td>
binary, directed, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_mutual_2">mutual(form=“min”,threshold=0)</a><br>
<p>
<em>Mutuality:</em> In binary ERGMs, equal to the number of pairs of actors <i>i</i> and <i>j</i> for which <i>(i,j)</i> and <i>(j,i)</i> both exist. For valued ERGMs, equal to <i>∑<em>{i&lt;j} m(y</em>{i,j},y_{j,i})</i>, where <i>m</i> is determined by <code>form</code> argument: <code>“min”</code> for <i>(y_{i,j},y_{j,i})</i>, <code>“nabsdiff”</code> for <i>-|y_{i,j},y_{j,i}|</i>, <code>“product”</code> for <i>y_{i,j}y_{j,i}</i>, and <code>“geometric”</code> for <i>√{y_{i,j}}√{y_{j,i}}</i>. See Krivitsky (2012) for a discussion of these statistics. <code>form=“threshold”</code> simply computes the binary <code>mutuality</code> after thresholding at <code>threshold</code>.
</p>
<p>
This term can only be used with directed networks. The binary version also has the following capabilities: if the optional <code>same</code> argument is passed (see Specifying Vertex Attributes and Levels for details), only mutual pairs that match on the attribute are counted; separate counts for each unique matching value can be obtained by using <code>diff=TRUE</code> with <code>same</code>; and if <code>by</code> is passed (again, see Specifying Vertex Attributes and Levels), then each node is counted separately for each mutual pair in which it occurs and the counts are tabulated by unique values of the attribute. This means that the sum of the mutual statistics when <code>by</code> is used will equal twice the standard mutual statistic. Only one of <code>same</code> or <code>by</code> may be used, and only the former is affected by <code>diff</code>; if both <code>same</code> and <code>by</code> are passed, <code>by</code> is ignored. Finally, if <code>levels</code> is passed, this tells which statistics should be kept whenever the <code>mutual</code> term would ordinarily result in multiple statistics (see Specifying Vertex Attributes and Levels).
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>.
</p>
</td>
<td>
valued, directed
</td>
</tr>
<tr>
<td>
<a id="term_nearsimmelian_1">nearsimmelian()</a><br>
<p>
<em>Near simmelian triads:</em> This term adds one statistic to the model equal to the number of near Simmelian triads, as defined by Krackhardt and Handcock (2007). This is a sub-graph of size three which is exactly one tie short of being complete. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_nodecov_1">nodecov(attr)</a><br>
<p>
<em>Main effect of a covariate:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the sum of <code>attr(i)</code> and <code>attr(j)</code> for all edges <i>(i,j)</i> in the network. For categorical attributes, see <code>nodefactor</code>. Note that for directed networks, <code>nodecov</code> equals <code>nodeicov</code> plus <code>nodeocov</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
binary, dyad-independent, frequently-used, directed, undirected, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodecov_2">nodecov(attr, form=“sum”)</a><br>
<p>
<em>Main effect of a covariate:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the sum of <code>attr(i)</code> and <code>attr(j)</code> for all edges <i>(i,j)</i> in the network. For categorical attributes, see <code>nodefactor</code>. Note that for directed networks, <code>nodecov</code> equals <code>nodeicov</code> plus <code>nodeocov</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
valued, dyad-independent, directed, undirected, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodemain_3">nodemain()</a><br>
<p>
<em>Main effect of a covariate:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the sum of <code>attr(i)</code> and <code>attr(j)</code> for all edges <i>(i,j)</i> in the network. For categorical attributes, see <code>nodefactor</code>. Note that for directed networks, <code>nodecov</code> equals <code>nodeicov</code> plus <code>nodeocov</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
binary, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_nodecovar_1">nodecovar(center, transform)</a><br>
<p>
<em>Covariance of undirected dyad values incident on each actor:</em> This term adds one statistic equal to <i>∑<em>{i,j&lt;k} y</em>{i,j}y_{i,k}/(n-2)</i>. This can be viewed as a valued analog of the <code>star(2)</code> statistic. If <code>center=TRUE</code>, the <i>y_{,}</i>s are centered by their mean over the whole network before the calculation. Note that this makes the model non-local, but it may alleviate multimodailty. If <code>transform=“sqrt”</code>, <i>y_{,}</i>s are repaced by their square roots before the calculation. This makes sense for counts in particular. If <code>center=TRUE</code> as well, they are centered by the mean of the square roots.
</p>
<p>
Note that this term replaces <code>nodesqrtcovar</code>, which has been deprecated in favor of <code>nodecovar(transform=“sqrt”)</code>.
</p>
</td>
<td>
valued, directed
</td>
</tr>
<tr>
<td>
<a id="term_nodecovar_1">nodecovar()</a><br>
<p>
<em>Uncentered covariance of dyad values incident on each actor:</em> This term adds one statistic equal to <i>∑<em>{i,j,k} (y</em>{i,j}y_{i,k}+y_{k,j}y_{k,j})</i>. This can be viewed as a valued analog of the <code>kstar(2)</code> statistic.
</p>
</td>
<td>
valued, directed, undirected, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodefactor_1">nodefactor(attr, base=1, levels=-1)</a><br>
<p>
<em>Factor attribute effect:</em> The <code>attr</code> argument specifies one or more categorical attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute (or each combination of the attributes given). Each of these statistics gives the number of times a node with that attribute or those attributes appears in an edge in the network.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodefactor(“fruit”, levels=-(2:3))</code>, <code>nodefactor(“fruit”, levels=c(1,4))</code>, and <code>nodefactor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_nodefactor_2">nodefactor(attr, base=1, levels=-1, form=“sum”)</a><br>
<p>
<em>Factor attribute effect:</em> The <code>attr</code> argument specifies one or more categorical attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute (or each combination of the attributes given). Each of these statistics gives the number of times a node with that attribute or those attributes appears in an edge in the network.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodefactor(“fruit”, levels=-(2:3))</code>, <code>nodefactor(“fruit”, levels=c(1,4))</code>, and <code>nodefactor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
</td>
<td>
dyad-independent, valued, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodeicov_1">nodeicov(attr)</a><br>
<p>
<em>Main effect of a covariate for in-edges:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total value of <code>attr(j)</code> for all edges <i>(i,j)</i> in the network. This term may only be used with directed networks. For categorical attributes, see <code>nodeifactor</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
binary, directed, quantitative nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_nodeicov_2">nodeicov(attr, form=“sum”)</a><br>
<p>
<em>Main effect of a covariate for in-edges:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total value of <code>attr(j)</code> for all edges <i>(i,j)</i> in the network. This term may only be used with directed networks. For categorical attributes, see <code>nodeifactor</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
valued, directed, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodeicovar_1">nodeicovar(center, transform)</a><br>
<p>
<em>Covariance of in-dyad values incident on each actor:</em> This term adds one statistic equal to <i>∑<em>{i,j,k} y</em>{j,i}y_{k,i}/(n-2)</i>. This can be viewed as a valued analog of the <code>istar(2)</code> statistic. If <code>center=TRUE</code>, the <i>y_{,}</i>s are centered by their mean over the whole network before the calculation. Note that this makes the model non-local, but it may alleviate multimodailty. If <code>transform=“sqrt”</code>, <i>y_{,}</i>s are repaced by their square roots before the calculation. This makes sense for counts in particular. If <code>center=TRUE</code> as well, they are centered by the mean of the square roots.
</p>
<p>
Note that this term replaces <code>nodeisqrtcovar</code>, which has been deprecated in favor of <code>nodeicovar(transform=“sqrt”)</code>.
</p>
</td>
<td>
valued, directed
</td>
</tr>
<tr>
<td>
<a id="term_nodeifactor_1">nodeifactor(attr, base=1, levels=-1)</a><br>
<p>
<em>Factor attribute effect for in-edges:</em> The <code>attr</code> argument specifies one or more categorical attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute (or each combination of the attributes given). Each of these statistics gives the number of times a node with that attribute or those attributes appears as the terminal node of a directed tie.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodeifactor(“fruit”, levels=-(2:3))</code>, <code>nodeifactor(“fruit”, levels=c(1,4))</code>, and <code>nodeifactor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
<p>
For an analogous term for quantitative vertex attributes, see <code>nodeicov</code>.
</p>
</td>
<td>
binary, dyad-independent, directed, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_nodeifactor_2">nodeifactor(attr, base=1, levels=-1, form=“sum”)</a><br>
<p>
<em>Factor attribute effect for in-edges:</em> The <code>attr</code> argument specifies one or more categorical attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute (or each combination of the attributes given). Each of these statistics gives the number of times a node with that attribute or those attributes appears as the terminal node of a directed tie.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodeifactor(“fruit”, levels=-(2:3))</code>, <code>nodeifactor(“fruit”, levels=c(1,4))</code>, and <code>nodeifactor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
<p>
For an analogous term for quantitative vertex attributes, see <code>nodeicov</code>.
</p>
</td>
<td>
valued, dyad-independent, directed, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodematch_1">nodematch(attr, diff=FALSE, keep=NULL, levels=NULL)</a><br>
<p>
<em>Uniform homophily and differential homophily:</em> The <code>attr</code> argument specifies one or more attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). When <code>diff=FALSE</code>, this term adds one network statistic to the model, which counts the number of edges <i>(i,j)</i> for which <code>attr(i)==attr(j)</code>. This is also called ”uniform homophily,” because each group is assumed to have the same propensity for within-group ties. When multiple attribute names are given, the statistic counts only ties for which all of the attributes match. When <code>diff=TRUE</code>, <i>p</i> network statistics are added to the model, where <i>p</i> is the number of unique values of the <code>attr</code> attribute. The <i>k</i>th such statistic counts the number of edges <i>(i,j)</i> for which <code>attr(i) == attr(j) == value(k)</code>, where <code>value(k)</code> is the <i>k</i>th smallest unique value of the <code>attr</code> attribute. This is also called ”differential homophily,” because each group is allowed to have a unique propensity for within-group ties. Note that a statistical test of uniform vs. differential homophily should be conducted using the ANOVA function.
</p>
<p>
By default, matches on all levels <i>k</i> are counted. The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodematch(“fruit”, levels=-(2:3))</code>, <code>nodematch(“fruit”, levels=c(1,4))</code>, and <code>nodematch(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels. This works for both <code>diff=TRUE</code> and <code>diff=FALSE</code>.
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>.
</p>
</td>
<td>
binary, dyad-independent, frequently-used, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodematch_2">nodematch(attr, diff=FALSE, keep=NULL, levels=NULL, form=“sum”)</a><br>
<p>
<em>Uniform homophily and differential homophily:</em> The <code>attr</code> argument specifies one or more attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). When <code>diff=FALSE</code>, this term adds one network statistic to the model, which counts the number of edges <i>(i,j)</i> for which <code>attr(i)==attr(j)</code>. This is also called ”uniform homophily,” because each group is assumed to have the same propensity for within-group ties. When multiple attribute names are given, the statistic counts only ties for which all of the attributes match. When <code>diff=TRUE</code>, <i>p</i> network statistics are added to the model, where <i>p</i> is the number of unique values of the <code>attr</code> attribute. The <i>k</i>th such statistic counts the number of edges <i>(i,j)</i> for which <code>attr(i) == attr(j) == value(k)</code>, where <code>value(k)</code> is the <i>k</i>th smallest unique value of the <code>attr</code> attribute. This is also called ”differential homophily,” because each group is allowed to have a unique propensity for within-group ties. Note that a statistical test of uniform vs. differential homophily should be conducted using the ANOVA function.
</p>
<p>
By default, matches on all levels <i>k</i> are counted. The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodematch(“fruit”, levels=-(2:3))</code>, <code>nodematch(“fruit”, levels=c(1,4))</code>, and <code>nodematch(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels. This works for both <code>diff=TRUE</code> and <code>diff=FALSE</code>.
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>.
</p>
</td>
<td>
valued, dyad-independent, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_match_3">match()</a><br>
<p>
<em>Uniform homophily and differential homophily:</em> The <code>attr</code> argument specifies one or more attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). When <code>diff=FALSE</code>, this term adds one network statistic to the model, which counts the number of edges <i>(i,j)</i> for which <code>attr(i)==attr(j)</code>. This is also called ”uniform homophily,” because each group is assumed to have the same propensity for within-group ties. When multiple attribute names are given, the statistic counts only ties for which all of the attributes match. When <code>diff=TRUE</code>, <i>p</i> network statistics are added to the model, where <i>p</i> is the number of unique values of the <code>attr</code> attribute. The <i>k</i>th such statistic counts the number of edges <i>(i,j)</i> for which <code>attr(i) == attr(j) == value(k)</code>, where <code>value(k)</code> is the <i>k</i>th smallest unique value of the <code>attr</code> attribute. This is also called ”differential homophily,” because each group is allowed to have a unique propensity for within-group ties. Note that a statistical test of uniform vs. differential homophily should be conducted using the ANOVA function.
</p>
<p>
By default, matches on all levels <i>k</i> are counted. The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodematch(“fruit”, levels=-(2:3))</code>, <code>nodematch(“fruit”, levels=c(1,4))</code>, and <code>nodematch(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels. This works for both <code>diff=TRUE</code> and <code>diff=FALSE</code>.
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>.
</p>
</td>
<td>
binary, directed, dyad-independent, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodemix_1">nodemix(attr, base=NULL, b1levels=NULL, b2levels=NULL, levels=NULL, levels2=-1)</a><br>
<p>
<em>Nodal attribute mixing:</em> The <code>attr</code> argument specifies one or more categorical vertex attributes (see Specifying Vertex Attributes and Levels for details). By default, this term adds one network statistic to the model for each possible pairing of attribute values. The statistic equals the number of edges in the network in which the nodes have that pairing of values. (When multiple attributes are specified, a statistic is added for each combination of attribute values for those attributes.) In other words, this term produces one statistic for every entry in the mixing matrix for the attribute(s). By default, the ordering of the attribute values is lexicographic: alphabetical (for nominal categories) or numerical (for ordered categories), but this can be overridden using the <code>levels</code> arguments. The optional arguments <code>levels</code>, <code>levels2</code>, <code>b1levels</code>, and <code>b2levels</code> control what statistics are included in the model, and the order in which they appear. <code>levels2</code> apply to all networks; <code>levels</code> applies to unipartite networks; <code>b1levels</code> and <code>b2levels</code> apply to bipartite networks (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>)).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels2</code> are passed, <code>levels2</code> overrides <code>base</code>.
</p>
</td>
<td>
binary, dyad-independent, frequently-used, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodemix_2">nodemix(attr, base=NULL, b1levels=NULL, b2levels=NULL, levels=NULL, levels2=-1, form=“sum”)</a><br>
<p>
<em>Nodal attribute mixing:</em> The <code>attr</code> argument specifies one or more categorical vertex attributes (see Specifying Vertex Attributes and Levels for details). By default, this term adds one network statistic to the model for each possible pairing of attribute values. The statistic equals the number of edges in the network in which the nodes have that pairing of values. (When multiple attributes are specified, a statistic is added for each combination of attribute values for those attributes.) In other words, this term produces one statistic for every entry in the mixing matrix for the attribute(s). By default, the ordering of the attribute values is lexicographic: alphabetical (for nominal categories) or numerical (for ordered categories), but this can be overridden using the <code>levels</code> arguments. The optional arguments <code>levels</code>, <code>levels2</code>, <code>b1levels</code>, and <code>b2levels</code> control what statistics are included in the model, and the order in which they appear. <code>levels2</code> apply to all networks; <code>levels</code> applies to unipartite networks; <code>b1levels</code> and <code>b2levels</code> apply to bipartite networks (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>)).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels2</code> are passed, <code>levels2</code> overrides <code>base</code>.
</p>
</td>
<td>
valued, dyad-independent, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodeocov_1">nodeocov(attr)</a><br>
<p>
<em>Main effect of a covariate for out-edges:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total value of <code>attr(i)</code> for all edges <i>(i,j)</i> in the network. This term may only be used with directed networks. For categorical attributes, see <code>nodeofactor</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
binary, directed, dyad-independent, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodeocov_2">nodeocov(attr, form=“sum”)</a><br>
<p>
<em>Main effect of a covariate for out-edges:</em> The <code>attr</code> argument specifies one or more quantitative attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds a single network statistic for each quantitative attribute or matrix column to the model equaling the total value of <code>attr(i)</code> for all edges <i>(i,j)</i> in the network. This term may only be used with directed networks. For categorical attributes, see <code>nodeofactor</code>.
</p>
<p>
Note that <code>ergm</code> versions 3.9.4 and earlier used different arguments for this term. See the above section on versioning for invoking the old behavior.
</p>
</td>
<td>
valued, directed, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_nodeocovar_1">nodeocovar(center, transform)</a><br>
<p>
<em>Covariance of out-dyad values incident on each actor:</em> This term adds one statistic equal to <i>∑<em>{i,j,k} y</em>{i,j}y_{i,k}/(n-2)</i>. This can be viewed as a valued analog of the <code>ostar(2)</code> statistic. If <code>center=TRUE</code>, the <i>y_{,}</i>s are centered by their mean over the whole network before the calculation. Note that this makes the model non-local, but it may alleviate multimodailty. If <code>transform=“sqrt”</code>, <i>y_{,}</i>s are repaced by their square roots before the calculation. This makes sense for counts in particular. If <code>center=TRUE</code> as well, they are centered by the mean of the square roots.
</p>
<p>
Note that this term replaces <code>nodeosqrtcovar</code>, which has been deprecated in favor of <code>nodeocovar(transform=“sqrt”)</code>.
</p>
</td>
<td>
valued, directed
</td>
</tr>
<tr>
<td>
<a id="term_nodeofactor_1">nodeofactor(attr, base=1, levels=-1)</a><br>
<p>
<em>Factor attribute effect for out-edges:</em> The <code>attr</code> argument specifies one or more categorical attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute (or each combination of the attributes given). Each of these statistics gives the number of times a node with that attribute or those attributes appears as the node of origin of a directed tie.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodeofactor(“fruit”, levels=-(2:3))</code>, <code>nodeofactor(“fruit”, levels=c(1,4))</code>, and <code>nodeofactor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
<p>
This term can only be used with directed networks.
</p>
</td>
<td>
binary, dyad-independent, directed, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_nodeofactor_2">nodeofactor(attr, base=1, levels=-1, form=“sum”)</a><br>
<p>
<em>Factor attribute effect for out-edges:</em> The <code>attr</code> argument specifies one or more categorical attributes (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the <code>attr</code> attribute (or each combination of the attributes given). Each of these statistics gives the number of times a node with that attribute or those attributes appears as the node of origin of a directed tie.
</p>
<p>
The optional <code>levels</code> argument controls which levels of the attribute should be included and which should be excluded. (See Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details.) For example, if the “fruit” attribute has levels “orange”, “apple”, “banana”, and “pear”, then to include just two levels, one for “apple” and one for “pear”, use any of <code>nodeofactor(“fruit”, levels=-(2:3))</code>, <code>nodeofactor(“fruit”, levels=c(1,4))</code>, and <code>nodeofactor(“fruit”, levels=c(“apple”, “pear”))</code>. Note: if you are using numeric values to specify the levels of a character variable, the levels will correspond to the alphabetically sorted character levels.
</p>
<p>
To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including <code>edges</code>. The default, <code>levels=-1</code>, is therefore to omit the first (in lexicographic order) attribute level. To include all levels, pass either <code>levels=TRUE</code> (i.e., keep all levels) or <code>levels=NULL</code> (i.e., do not filter levels).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>base</code>.
</p>
<p>
This term can only be used with directed networks.
</p>
</td>
<td>
valued, dyad-independent, categorical nodal attribute, directed
</td>
</tr>
<tr>
<td>
<a id="term_nsp_1">nsp(d)</a><br>
<p>
<em>Nonedgewise shared partners:</em> This is just like the <code>dsp</code> and <code>esp</code> terms, except this term adds one network statistic to the model for each element in <code>d</code> where the <i>i</i>th such statistic equals the number of <em>non-edges</em> (that is, dyads that do not have an edge) in the network with exactly <code>d[i]</code> shared partners. This term can be used with directed and undirected networks.
</p>
<p>
For directed networks, only outgoing two-path (“OTP”) shared partners are counted. In other words, for a (directed) non-edge <code>(i,j)</code> in a directed graph, the number of shared partners counted by <code>nsp</code> is the number of nodes <code>k</code> that have edges <code>i -&gt; k -&gt; j</code>. (These may also be called homogeneous shared partners.) To count other types of shared partners instead, see <code>dnsp</code>.
</p>
</td>
<td>
binary, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_odegrange_1">odegrange(from, to=+Inf, by=NULL, homophily=FALSE, levels=NULL)</a><br>
<p>
<em>Out-degree range:</em> The <code>from</code> and <code>to</code> arguments are vectors of distinct integers (or <code>+Inf</code>, for <code>to</code> (its default)). If one of the vectors has length 1, it is recycled to the length of the other. Otherwise, they must have the same length. This term adds one network statistic to the model for each element of <code>from</code> (or <code>to</code>); the <i>i</i>th such statistic equals the number of nodes in the network of out-degree greater than or equal to <code>from[i]</code> but strictly less than <code>to[i]</code>, i.e. with out-edge count in semiopen interval <code>[from,to)</code>. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified and <code>homophily</code> is <code>TRUE</code>, then degrees are calculated using the subnetwork consisting of only edges whose endpoints have the same value of the <code>by</code> attribute. If <code>by</code> is specified and <code>homophily</code> is <code>FALSE</code> (the default), then separate degree range statistics are calculated for nodes having each separate value of the attribute.
</p>
<p>
This term can only be used with directed networks; for undirected networks (bipartite and not) see <code>degrange</code>. For degrees of specific modes of bipartite networks, see <code>b1degrange</code> and <code>b2degrange</code>. For in-degrees, see <code>idegrange</code>.
</p>
</td>
<td>
binary, directed, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_odegree_1">odegree(d, by=NULL, homophily=FALSE, levels=NULL)</a><br>
<p>
<em>Out-degree:</em> The <code>d</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>d</code>; the <i>i</i>th such statistic equals the number of nodes in the network of out-degree <code>d[i]</code>, i.e. the number of nodes with exactly <code>d[i]</code> out-edges. The optional argument <code>by</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified and <code>homophily</code> is <code>TRUE</code>, then degrees are calculated using the subnetwork consisting of only edges whose endpoints have the same value of the <code>by</code> attribute. If <code>by</code> is specified and <code>homophily</code> is <code>FALSE</code> (the default), then separate degree statistics are calculated for nodes having each separate value of the attribute. This term can only be used with directed networks; for undirected networks see <code>degree</code>.
</p>
</td>
<td>
binary, directed, categorical nodal attribute, frequently-used
</td>
</tr>
<tr>
<td>
<a id="term_odegree1.5_1">odegree1.5()</a><br>
<p>
<em>Out-degree to the 3/2 power:</em> This term adds one network statistic to the model equaling the sum over the actors of each actor’s outdegree taken to the 3/2 power (or, equivalently, multiplied by its square root). This term is analogous to the term of Snijders et al. (2010), equation (12). This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed
</td>
</tr>
<tr>
<td>
<a id="term_odegreepopularity_1">odegreepopularity()</a><br>
<p>
<em>Out-degree popularity (deprecated):</em> see <code>odegree1.5</code>.
</p>
</td>
<td>
binary, directed, deprecated
</td>
</tr>
<tr>
<td>
<a id="term_opentriad_1">opentriad()</a><br>
<p>
<em>Open triads:</em> This term adds one statistic to the model equal to the number of 2-stars minus three times the number of triangles in the network. It is currently only implemented for undirected networks.
</p>
</td>
<td>
binary, undirected, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_ostar_1">ostar(k, attr=NULL, levels=NULL)</a><br>
<p>
<em>k-Outstars:</em> The <code>k</code> argument is a vector of distinct integers. This term adds one network statistic to the model for each element in <code>k</code>. The <i>i</i>th such statistic counts the number of distinct <code>k[i]</code>-outstars in the network, where a <i>k</i>-outstar is defined to be a node <i>N</i> and a set of <i>k</i> different nodes <i>{O[1], …, O[k]}</i> such that the ties <i>(N,O_j)</i> exist for <i>j=1, …, k</i>. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If this is specified then the count is the number of <i>k</i>-outstars where all nodes have the same value of the attribute. This term can only be used with directed networks; for undirected networks see <code>kstar</code>. Note that <code>ostar(1)</code> is equal to both <code>istar(1)</code> and <code>edges</code>.
</p>
</td>
<td>
binary, directed, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_receiver_1">receiver(base=1, nodes=-1)</a><br>
<p>
<em>Receiver effect:</em> This term adds one network statistic for each node equal to the number of in-ties for that node. This measures the popularity of the node. The term for the first node is omitted by default because of linear dependence that arises if this term is used together with <code>edges</code>, but its coefficient can be computed as the negative of the sum of the coefficients of all the other actors. That is, the average coefficient is zero, following the Holland-Leinhardt parametrization of the <span class="math inline">\(p_1\)</span> model (Holland and Leinhardt, 1981). The <code>base</code> and <code>nodes</code> arguments allow the user to determine which nodes’ statistics should be included or excluded (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). The argument <code>nodes</code> is preferred to <code>base</code>, although <code>base</code> carries a default value of 1 for backwards compatibility. (If both <code>base</code> and <code>nodes</code> are supplied, then <code>nodes</code> overrides <code>base</code>.) This term can only be used with directed networks. For undirected networks, see <code>sociality</code>.
</p>
</td>
<td>
binary, directed, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_receiver_2">receiver(base=1, nodes=-1, form=“sum”)</a><br>
<p>
<em>Receiver effect:</em> This term adds one network statistic for each node equal to the number of in-ties for that node. This measures the popularity of the node. The term for the first node is omitted by default because of linear dependence that arises if this term is used together with <code>edges</code>, but its coefficient can be computed as the negative of the sum of the coefficients of all the other actors. That is, the average coefficient is zero, following the Holland-Leinhardt parametrization of the <span class="math inline">\(p_1\)</span> model (Holland and Leinhardt, 1981). The <code>base</code> and <code>nodes</code> arguments allow the user to determine which nodes’ statistics should be included or excluded (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). The argument <code>nodes</code> is preferred to <code>base</code>, although <code>base</code> carries a default value of 1 for backwards compatibility. (If both <code>base</code> and <code>nodes</code> are supplied, then <code>nodes</code> overrides <code>base</code>.) This term can only be used with directed networks. For undirected networks, see <code>sociality</code>.
</p>
</td>
<td>
valued, directed, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_sender_1">sender(base=1, nodes=-1)</a><br>
<p>
<em>Sender effect:</em> This term adds one network statistic for each node equal to the number of out-ties for that node. This measures the activity of the node. The term for the first node is omitted by default because of linear dependence that arises if this term is used together with <code>edges</code>, but its coefficient can be computed as the negative of the sum of the coefficients of all the other actors. That is, the average coefficient is zero, following the Holland-Leinhardt parametrization of the <span class="math inline">\(p_1\)</span> model (Holland and Leinhardt, 1981). The <code>nodes</code> arguments allow the user to determine which nodes’ statistics should be included or excluded (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>nodes</code> are passed, <code>nodes</code> overrides <code>base</code>.
</p>
<p>
This term can only be used with directed networks. For undirected networks, see <code>sociality</code>.
</p>
</td>
<td>
binary, directed, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_sender_2">sender(base=1, nodes=-1, form=“sum”)</a><br>
<p>
<em>Sender effect:</em> This term adds one network statistic for each node equal to the number of out-ties for that node. This measures the activity of the node. The term for the first node is omitted by default because of linear dependence that arises if this term is used together with <code>edges</code>, but its coefficient can be computed as the negative of the sum of the coefficients of all the other actors. That is, the average coefficient is zero, following the Holland-Leinhardt parametrization of the <span class="math inline">\(p_1\)</span> model (Holland and Leinhardt, 1981). The <code>nodes</code> arguments allow the user to determine which nodes’ statistics should be included or excluded (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details).
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>nodes</code> are passed, <code>nodes</code> overrides <code>base</code>.
</p>
<p>
This term can only be used with directed networks. For undirected networks, see <code>sociality</code>.
</p>
</td>
<td>
valued, directed, dyad-independent
</td>
</tr>
<tr>
<td>
<a id="term_simmelian_1">simmelian()</a><br>
<p>
<em>Simmelian triads:</em> This term adds one statistic to the model equal to the number of Simmelian triads, as defined by Krackhardt and Handcock (2007). This is a complete sub-graph of size three. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_simmelianties_1">simmelianties()</a><br>
<p>
<em>Ties in simmelian triads:</em> This term adds one statistic to the model equal to the number of ties in the network that are associated with Simmelian triads, as defined by Krackhardt and Handcock (2007). Each Simmelian has six ties in it but, because Simmelians can overlap in terms of nodes (and associated ties), the total number of ties in these Simmelians is less than six times the number of Simmelians. Hence this is a measure of the clustering of Simmelians (given the number of Simmelians). This term can only be used with directed networks.
</p>
</td>
<td>
binary, triad-related, directed
</td>
</tr>
<tr>
<td>
<a id="term_smalldiff_1">smalldiff(attr, cutoff)</a><br>
<p>
<em>Number of ties between actors with similar (but not necessarily identical) attribute values:</em> The <code>attr</code> argument specifies a quantitative vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). This term adds one statistic, having as its value the number of edges in the network for which the incident actors’ attribute values differ less than <code>cutoff</code>; that is, number of edges between <code>i</code> to <code>j</code> such that <code>abs(attr[i]-attr[j])&lt;cutoff</code>.
</p>
</td>
<td>
binary, dyad-independent, directed, undirected, quantitative nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_sociality_1">sociality(attr=NULL, base=1, levels=NULL, nodes=-1)</a><br>
<p>
<em>Undirected degree:</em> This term adds one network statistic for each node equal to the number of ties of that node. This term can only be used with undirected networks. For directed networks, see <code>sender</code> and <code>receiver</code>. By default, <code>nodes=-1</code> means that the statistic for the first node will be omitted, but this argument may be changed to control which statistics are included just as for the <code>nodes</code> argument of <code>sender</code> and <code>receiver</code> terms.
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>nodes</code> are passed, <code>nodes</code> overrides <code>base</code>.
</p>
<p>
The optional <code>attr</code> argument is deprecated and will be replaced with a more elegant implementation in a future release. In the meantime, it specifies a categorical vertex attribute (see Specifying Vertex Attributes and Levels for details). If provided, this term only counts ties between nodes with the same value of the attribute (an actor-specific version of the <code>nodematch</code> term), restricted to be one of the values specified by (also deprecated) <code>levels</code> if <code>levels</code> is not <code>NULL</code>.
</p>
</td>
<td>
binary, undirected, dyad-independent, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_sociality_2">sociality(attr=NULL, base=1, levels=NULL, nodes=-1, form=“sum”)</a><br>
<p>
<em>Undirected degree:</em> This term adds one network statistic for each node equal to the number of ties of that node. This term can only be used with undirected networks. For directed networks, see <code>sender</code> and <code>receiver</code>. By default, <code>nodes=-1</code> means that the statistic for the first node will be omitted, but this argument may be changed to control which statistics are included just as for the <code>nodes</code> argument of <code>sender</code> and <code>receiver</code> terms.
</p>
<p>
The argument <code>base</code> is retained for backwards compatibility and may be removed in a future version. When both <code>base</code> and <code>nodes</code> are passed, <code>nodes</code> overrides <code>base</code>.
</p>
<p>
The optional <code>attr</code> argument is deprecated and will be replaced with a more elegant implementation in a future release. In the meantime, it specifies a categorical vertex attribute (see Specifying Vertex Attributes and Levels for details). If provided, this term only counts ties between nodes with the same value of the attribute (an actor-specific version of the <code>nodematch</code> term), restricted to be one of the values specified by (also deprecated) <code>levels</code> if <code>levels</code> is not <code>NULL</code>.
</p>
</td>
<td>
valued, undirected, dyad-independent, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_sum_1">sum(pow=1)</a><br>
<p>
<em>Sum of dyad values (optionally taken to a power):</em> This term adds one statistic equal to the sum of dyad values taken to the power <code>pow</code>, which defaults to 1.
</p>
</td>
<td>
valued, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_threetrail_1">threetrail(keep=NULL, levels=NULL)</a><br>
<p>
<em> Three-trails:</em> a.k.a. <code>threepath</code>. For an undirected network, this term adds one statistic equal to the number of 3-trails, where a 3-trail is defined as a “trail” of length three that traverses three distinct edges. Note that a 3-trail need not include four distinct nodes; in particular, a triangle counts as three 3-trails. For a directed network, this term adds four statistics (or some subset of these four specified by the <code>levels</code> argument), one for each of the four distinct types of directed three-paths. If the nodes of the path are written from left to right such that the middle edge points to the right (R), then the four types are RRR, RRL, LRR, and LRL. That is, an RRR 3-trail is of the form <i>i–&gt;j–&gt;k–&gt;l</i>, and RRL 3-trail is of the form <i>i–&gt;j–&gt;k&lt;–l</i>, etc. Like in the undirected case, there is no requirement that the nodes be distinct in a directed 3-trail. However, the three edges must all be distinct. Thus, a mutual tie <i>i&lt;–&gt;j</i> does not count as a 3-trail of the form <i>i–&gt;j–&gt;i&lt;–j</i>; however, in the subnetwork <i>i&lt;–&gt;j–&gt;k</i>, there are two directed 3-trails, one LRR (<i>k&lt;–j–&gt;i–&gt;j</i>) and one RRR (<i>k&lt;–j–&gt;i–&gt;j</i>).
</p>
<p>
The argument <code>keep</code> is retained for backwards compatibility and may be removed in a future version. When both <code>keep</code> and <code>levels</code> are passed, <code>levels</code> overrides <code>keep</code>. This term used to be (inaccurately) called <code>threepath</code>. That name has been deprecated and may be removed in a future version.
</p>
</td>
<td>
binary, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_transitive_1">transitive()</a><br>
<p>
<em>Transitive triads:</em> This term adds one statistic to the model, equal to the number of triads in the network that are transitive. The transitive triads are those of type <code>120D</code>, <code>030T</code>, <code>120U</code>, or <code>300</code> in the categorization of Davis and Leinhardt (1972). For details on the 16 possible triad types, see <code>triad.classify</code> in the <code>sna</code> package. Note the distinction from the <code>ttriple</code> term. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_transitiveties_1">transitiveties(attr=NULL, levels=NULL)</a><br>
<p>
<em>Transitive ties:</em> This term adds one statistic, equal to the number of ties <i>i–&gt;j</i> such that there exists a two-path from <i>i</i> to <i>j</i>. (Related to the <code>ttriple</code> term.) The binary version takes a nodal attribute <code>attr</code>, and, if given, all three nodes involved (<i>i</i>, <i>j</i>, and the node on the two-path) must match on this attribute in order for <i>i–&gt;j</i> to be counted.
</p>
</td>
<td>
binary, directed, undirected, triad-related, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_transitiveties_2">transitiveties(threshold=0)</a><br>
<p>
<em>Transitive ties:</em> This term adds one statistic, equal to the number of ties <i>i–&gt;j</i> such that there exists a two-path from <i>i</i> to <i>j</i>. (Related to the <code>ttriple</code> term.) The binary version takes a nodal attribute <code>attr</code>, and, if given, all three nodes involved (<i>i</i>, <i>j</i>, and the node on the two-path) must match on this attribute in order for <i>i–&gt;j</i> to be counted.
</p>
</td>
<td>
valued, directed, undirected, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_transitiveweights_1">transitiveweights(twopath=“min”,combine=“max”,affect=“min”)</a><br>
<p>
<em>Transitive weights:</em> This statistic implements the transitive weights statistic defined by Krivitsky (2012), Equation 13. The currently implemented options for <code>twopath</code> is the minimum of the constituent dyads (<code>“min”</code>) or their geometric mean (<code>“geomean”</code>); for <code>combine</code>, the maximum of the 2-path strengths (<code>“max”</code>) or their sum (<code>“sum”</code>); and for <code>affect</code>, the minimum of the focus dyad and the combined strength of the two paths (<code>“min”</code>) or their geometric mean (<code>“geomean”</code>). For each of these options, the first (and the default) is more stable but also more conservative, while the second is more sensitive but more likely to induce a multimodal distribution of networks.
</p>
</td>
<td>
valued, directed, undirected, non-negative, triad-related
</td>
</tr>
<tr>
<td>
<a id="term_triadcensus_1">triadcensus(levels)</a><br>
<p>
<em>Triad census:</em> For a directed network, this term adds one network statistic for each of an arbitrary subset of the 16 possible types of triads categorized by Davis and Leinhardt (1972) as <code>003, 012, 102, 021D, 021U, 021C, 111D, 111U, 030T, 030C, 201, 120D, 120U, 120C, 210,</code> and <code>300</code>. Note that at least one category should be dropped; otherwise a linear dependency will exist among the 16 statistics, since they must sum to the total number of three-node sets. By default, the category <code>003</code>, which is the category of completely empty three-node sets, is dropped. This is considered category zero, and the others are numbered 1 through 15 in the order given above. By using the <code>levels</code> argument (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details), the user may specify a set of terms to add other than the default value of <code>1:15</code>. Each statistic is the count of the corresponding triad type in the network. For details on the 16 types, see <code>?triad.classify</code> in the <code>{sna}</code> package, on which this code is based. For an undirected network, the triad census is over the four types defined by the number of ties (i.e., 0, 1, 2, and 3), and the default is to add <code>1:3</code>, which is to say that the 0 is dropped; however, this too may be controlled by changing the <code>levels</code> argument.
</p>
</td>
<td>
binary, triad-related, directed, undirected
</td>
</tr>
<tr>
<td>
<a id="term_triangle_1">triangle(attr=NULL, diff=FALSE, levels=NULL)</a><br>
<p>
<em>Triangles:</em> By default, this term adds one statistic to the model equal to the number of triangles in the network. For an undirected network, a triangle is defined to be any set <i>{(i,j), (j,k), (k,i)}</i> of three edges. For a directed network, a triangle is defined as any set of three edges <i>(i,j)</i> and <i>(j,k)</i> and either <i>(k,i)</i> or <i>(i,k)</i>. The former case is called a “transitive triple” and the latter is called a “cyclic triple”, so in the case of a directed network, <code>triangle</code> equals <code>ttriple</code> plus <code>ctriple</code> — thus at most two of these three terms can be in a model. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code>, then the count is restricted to those triples of nodes with equal values of the vertex attribute specified by <code>attr</code>. If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code>, then one statistic is added for each value of <code>attr</code> (or each value specified by <code>levels</code> if that argument is passed), equal to the number of triangles where all three nodes have that value of the attribute.
</p>
</td>
<td>
binary, frequently-used, triad-related, directed, undirected, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_tripercent_1">tripercent(attr=NULL, diff=FALSE, levels=NULL)</a><br>
<p>
<em>Triangle percentage:</em> By default, this term adds one statistic to the model equal to 100 times the ratio of the number of triangles in the network to the sum of the number of triangles and the number of 2-stars not in triangles (the latter is considered a potential but incomplete triangle). In case the denominator equals zero, the statistic is defined to be zero. For the definition of triangle, see <code>triangle</code>. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code>, the counts (both numerator and denominator) are restricted to those triples of nodes with equal values of the vertex attribute specified by <code>attr</code>. If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code>, then one statistic is added for each value of <code>attr</code> (or each value specified by <code>levels</code> if that argument is passed), where the counts (both numerator and denominator) are restricted to those triples of nodes with that value of the vertex attribute specified by <code>attr</code>. This is often called the mean correlation coefficient. This term can only be used with undirected networks; for directed networks, it is difficult to define the numerator and denominator in a consistent and meaningful way.
</p>
</td>
<td>
binary, undirected, triad-related, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_ttriple_1">ttriple(attr=NULL, diff=FALSE, levels=NULL)</a><br>
<p>
<em>Transitive triples:</em> By default, this term adds one statistic to the model, equal to the number of transitive triples in the network, defined as a set of edges <i>{(i,j), (j,k), (i,k)}</i>. Note that <code>triangle</code> equals <code>ttriple+ctriple</code> for a directed network, so at most two of the three terms can be in a model. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code>, then the count is over the number of transitive triples where all three nodes have the same value of the attribute. If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code>, then one statistic is added for each value of <code>attr</code> (or each value of <code>attr</code> specified by <code>levels</code> if that argument is passed), equal to the number of transitive triples where all three nodes have that value of <code>attr</code>. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_ttriad_2">ttriad()</a><br>
<p>
<em>Transitive triples:</em> By default, this term adds one statistic to the model, equal to the number of transitive triples in the network, defined as a set of edges <i>{(i,j), (j,k), (i,k)}</i>. Note that <code>triangle</code> equals <code>ttriple+ctriple</code> for a directed network, so at most two of the three terms can be in a model. The optional argument <code>attr</code> specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code style="white-space: pre;">? nodal_attributes</code>) for details). If <code>attr</code> is specified and <code>diff</code> is <code>FALSE</code>, then the count is over the number of transitive triples where all three nodes have the same value of the attribute. If <code>attr</code> is specified and <code>diff</code> is <code>TRUE</code>, then one statistic is added for each value of <code>attr</code> (or each value of <code>attr</code> specified by <code>levels</code> if that argument is passed), equal to the number of transitive triples where all three nodes have that value of <code>attr</code>. This term can only be used with directed networks.
</p>
</td>
<td>
binary, directed, triad-related, categorical nodal attribute
</td>
</tr>
<tr>
<td>
<a id="term_twopath_1">twopath()</a><br>
<p>
<em>2-Paths:</em> This term adds one statistic to the model, equal to the number of 2-paths in the network. For a directed network this is defined as a pair of edges <i>(i,j), (j,k)</i>, where <i>i</i> and <i>j</i> must be distinct. That is, it is a directed path of length 2 from <i>i</i> to <i>k</i> via <i>j</i>. For directed networks a 2-path is also a mixed 2-star but the interpretation is usually different; see <code>m2star</code>. For undirected networks a twopath is defined as a pair of edges <i>{i,j}, {j,k}</i>. That is, it is an undirected path of length 2 from <i>i</i> to <i>k</i> via <i>j</i>, also known as a 2-star.
</p>
</td>
<td>
binary, directed, undirected
</td>
</tr>
</table>
</blockquote>
</div>
<div id="term-index-by-category" class="section level2">
<h2>Term index by category</h2>
<p>Note that currently the categories are somewhat ambiguous in their exclusivity. For example, a term marked as ‘directed’ can not be used with an undirected network, but a term not marked with either ‘directed’ or ‘undirected’ can be used with both. (rename to ‘directed-only’ ?)</p>
Jump to category:<a href="#cat_valued">valued</a> <a href="#cat_operator">operator</a> <a href="#cat_binary">binary</a> <a href="#cat_directed">directed</a> <a href="#cat_dyad-independent">dyad-independent</a> <a href="#cat_frequently-used">frequently-used</a> <a href="#cat_undirected">undirected</a> <a href="#cat_quantitative nodal attribute">quantitative nodal attribute</a> <a href="#cat_categorical nodal attribute">categorical nodal attribute</a> <a href="#cat_curved">curved</a> <a href="#cat_triad-related">triad-related</a> <a href="#cat_bipartite">bipartite</a> <a href="#cat_deprecated">deprecated</a> <a href="#cat_non-negative">non-negative</a>
<h3>
<a id="cat_valued">valued</a>
</h3>
<ul>
<li>
<a href="#term_B_1">B</a> :
</li>
<li>
<a href="#term_Curve_6">Curve</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Exp_2">Exp</a> : Exponentiate a network’s statisti
</li>
<li>
<a href="#term_Log_2">Log</a> : Take a natural logarithm of a network’s statisti
</li>
<li>
<a href="#term_Prod_2">Prod</a> : A product (or an arbitrary power combination) of one or more formula
</li>
<li>
<a href="#term_Sum_2">Sum</a> : A sum (or an arbitrary linear combination) of one or more formula
</li>
<li>
<a href="#term_Label_2">Label</a> : Modify terms’ coefficient name
</li>
<li>
<a href="#term_absdiff_2">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiffcat_2">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_atleast_1">atleast</a> : Number of dyads with values greater than or equal to a threshol
</li>
<li>
<a href="#term_atmost_1">atmost</a> : Number of dyads with values less than or equal to a threshol
</li>
<li>
<a href="#term_b1cov_2">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_2">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1sociality_2">b1sociality</a> : Degree
</li>
<li>
<a href="#term_b2cov_2">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_2">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2sociality_2">b2sociality</a> : Degree
</li>
<li>
<a href="#term_cyclicalties_2">cyclicalties</a> : Cyclical ties
</li>
<li>
<a href="#term_cyclicalweights_1">cyclicalweights</a> : Cyclical weights
</li>
<li>
<a href="#term_diff_2">diff</a> : Difference
</li>
<li>
<a href="#term_edgecov_2">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edges_1">edges</a> : Edges
</li>
<li>
<a href="#term_nonzero_2">nonzero</a> : Edges
</li>
<li>
<a href="#term_equalto_1">equalto</a> : Number of dyads with values equal to a specific value (within tolerance)
</li>
<li>
<a href="#term_greaterthan_1">greaterthan</a> : Number of dyads with values strictly greater than a threshold
</li>
<li>
<a href="#term_ininterval_1">ininterval</a> : Number of dyads whose values are in an interva
</li>
<li>
<a href="#term_smallerthan_1">smallerthan</a> : Number of dyads with values strictly smaller than a threshold
</li>
<li>
<a href="#term_mm_2">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mutual_2">mutual</a> : Mutuality
</li>
<li>
<a href="#term_nodecov_2">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodecovar_1">nodecovar</a> :
</li>
<li>
<a href="#term_nodecovar_1">nodecovar</a> : Uncentered covariance of dyad values incident on each actor
</li>
<li>
<a href="#term_nodefactor_2">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodeicov_2">nodeicov</a> : Main effect of a covariate for in-edges
</li>
<li>
<a href="#term_nodeicovar_1">nodeicovar</a> :
</li>
<li>
<a href="#term_nodeifactor_2">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodematch_2">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodemix_2">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodeocov_2">nodeocov</a> : Main effect of a covariate for out-edges
</li>
<li>
<a href="#term_nodeocovar_1">nodeocovar</a> :
</li>
<li>
<a href="#term_nodeofactor_2">nodeofactor</a> : Factor attribute effect for out-edges
</li>
<li>
<a href="#term_receiver_2">receiver</a> : Receiver effect
</li>
<li>
<a href="#term_sender_2">sender</a> : Sender effect
</li>
<li>
<a href="#term_sociality_2">sociality</a> : Undirected degree
</li>
<li>
<a href="#term_sum_1">sum</a> : Sum of dyad values (optionally taken to a power)
</li>
<li>
<a href="#term_transitiveties_2">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_transitiveweights_1">transitiveweights</a> : Transitive weights
</li>
</ul>
<h3>
<a id="cat_operator">operator</a>
</h3>
<ul>
<li>
<a href="#term_B_1">B</a> :
</li>
<li>
<a href="#term_Parametrize_1">Parametrize</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Parametrise_2">Parametrise</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Curve_3">Curve</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Parametrize_4">Parametrize</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Parametrise_5">Parametrise</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Curve_6">Curve</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Exp_1">Exp</a> : Exponentiate a network’s statisti
</li>
<li>
<a href="#term_Exp_2">Exp</a> : Exponentiate a network’s statisti
</li>
<li>
<a href="#term_F_1">F</a> : Filtering on arbitrary one-term model
</li>
<li>
<a href="#term_Log_1">Log</a> : Take a natural logarithm of a network’s statisti
</li>
<li>
<a href="#term_Log_2">Log</a> : Take a natural logarithm of a network’s statisti
</li>
<li>
<a href="#term_Prod_1">Prod</a> : A product (or an arbitrary power combination) of one or more formula
</li>
<li>
<a href="#term_Prod_2">Prod</a> : A product (or an arbitrary power combination) of one or more formula
</li>
<li>
<a href="#term_S_1">S</a> : Evaluation on an induced subgrap
</li>
<li>
<a href="#term_Sum_1">Sum</a> : A sum (or an arbitrary linear combination) of one or more formula
</li>
<li>
<a href="#term_Sum_2">Sum</a> : A sum (or an arbitrary linear combination) of one or more formula
</li>
<li>
<a href="#term_Symmetrize_1">Symmetrize</a> : Evaluation on symmetrized (undirected) networ
</li>
<li>
<a href="#term_Label_1">Label</a> : Modify terms’ coefficient name
</li>
<li>
<a href="#term_Label_2">Label</a> : Modify terms’ coefficient name
</li>
<li>
<a href="#term_NodematchFilter_1">NodematchFilter</a> : Filtering on list(list(“nodematch”)
</li>
<li>
<a href="#term_Offset_1">Offset</a> : Terms with fixed coefficient
</li>
</ul>
<h3>
<a id="cat_binary">binary</a>
</h3>
<ul>
<li>
<a href="#term_Parametrize_1">Parametrize</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Parametrise_2">Parametrise</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Curve_3">Curve</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Parametrize_4">Parametrize</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Parametrise_5">Parametrise</a> : Impose a curved structure on term parameters
</li>
<li>
<a href="#term_Exp_1">Exp</a> : Exponentiate a network’s statisti
</li>
<li>
<a href="#term_F_1">F</a> : Filtering on arbitrary one-term model
</li>
<li>
<a href="#term_Log_1">Log</a> : Take a natural logarithm of a network’s statisti
</li>
<li>
<a href="#term_Prod_1">Prod</a> : A product (or an arbitrary power combination) of one or more formula
</li>
<li>
<a href="#term_S_1">S</a> : Evaluation on an induced subgrap
</li>
<li>
<a href="#term_Sum_1">Sum</a> : A sum (or an arbitrary linear combination) of one or more formula
</li>
<li>
<a href="#term_Symmetrize_1">Symmetrize</a> : Evaluation on symmetrized (undirected) networ
</li>
<li>
<a href="#term_Label_1">Label</a> : Modify terms’ coefficient name
</li>
<li>
<a href="#term_NodematchFilter_1">NodematchFilter</a> : Filtering on list(list(“nodematch”)
</li>
<li>
<a href="#term_Offset_1">Offset</a> : Terms with fixed coefficient
</li>
<li>
<a href="#term_absdiff_1">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiffcat_1">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_altkstar_1">altkstar</a> : Alternating k-star
</li>
<li>
<a href="#term_asymmetric_1">asymmetric</a> : Asymmetric dyads
</li>
<li>
<a href="#term_attrcov_1">attrcov</a> : Edge covariate by attribute pairing
</li>
<li>
<a href="#term_b1concurrent_1">b1concurrent</a> : Concurrent node count for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1cov_1">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1degrange_1">b1degrange</a> : Degree range for the first mode in a bipartite (a.k.a. two-mode) network
</li>
<li>
<a href="#term_b1degree_1">b1degree</a> : Degree for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1dsp_1">b1dsp</a> : Dyadwise shared partners for dyads in the first bipartition
</li>
<li>
<a href="#term_b1factor_1">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1mindegree_1">b1mindegree</a> : Minimum degree for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1nodematch_1">b1nodematch</a> : Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1sociality_1">b1sociality</a> : Degree
</li>
<li>
<a href="#term_b1star_1">b1star</a> : k-Stars for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1starmix_1">b1starmix</a> : Mixing matrix for k-stars centered on the first mode of a bipartite network
</li>
<li>
<a href="#term_b1twostar_1">b1twostar</a> : Two-star census for central nodes centered on the first mode of a bipartite network
</li>
<li>
<a href="#term_b2concurrent_1">b2concurrent</a> : Concurrent node count for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_1">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2degrange_1">b2degrange</a> : Degree range for the second mode in a bipartite (a.k.a. two-mode) network
</li>
<li>
<a href="#term_b2degree_1">b2degree</a> : Degree for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2dsp_1">b2dsp</a> : Dyadwise shared partners for dyads in the second bipartition
</li>
<li>
<a href="#term_b2factor_1">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2mindegree_1">b2mindegree</a> : Minimum degree for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2nodematch_1">b2nodematch</a> : Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2sociality_1">b2sociality</a> : Degree
</li>
<li>
<a href="#term_b2star_1">b2star</a> : k-Stars for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2starmix_1">b2starmix</a> : Mixing matrix for k-stars centered on the second mode of a bipartite network
</li>
<li>
<a href="#term_b2twostar_1">b2twostar</a> : Two-star census for central nodes centered on the second mode of a bipartite network
</li>
<li>
<a href="#term_balance_1">balance</a> : Balanced triads
</li>
<li>
<a href="#term_coincidence_1">coincidence</a> : Coincident node count for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_concurrent_1">concurrent</a> : Concurrent node count
</li>
<li>
<a href="#term_concurrentties_1">concurrentties</a> : Concurrent tie count
</li>
<li>
<a href="#term_ctriple_1">ctriple</a> : Cyclic triples
</li>
<li>
<a href="#term_ctriad_2">ctriad</a> : Cyclic triples
</li>
<li>
<a href="#term_cycle_1">cycle</a> : k-Cycle Census
</li>
<li>
<a href="#term_cyclicalties_1">cyclicalties</a> : Cyclical ties
</li>
<li>
<a href="#term_ddsp_1">ddsp</a> :
</li>
<li>
<a href="#term_degrange_1">degrange</a> : Degree range
</li>
<li>
<a href="#term_degree_1">degree</a> : Degree
</li>
<li>
<a href="#term_degree1.5_1">degree1.5</a> : Degree to the 3/2 power
</li>
<li>
<a href="#term_degreepopularity_1">degreepopularity</a> : Degree popularity (deprecated)
</li>
<li>
<a href="#term_degcrossprod_1">degcrossprod</a> : Degree Cross-Product
</li>
<li>
<a href="#term_degcor_1">degcor</a> : Degree Correlation
</li>
<li>
<a href="#term_density_1">density</a> : Density
</li>
<li>
<a href="#term_diff_1">diff</a> : Difference
</li>
<li>
<a href="#term_desp_1">desp</a> :
</li>
<li>
<a href="#term_dgwdsp_1">dgwdsp</a> :
</li>
<li>
<a href="#term_dgwesp_1">dgwesp</a> :
</li>
<li>
<a href="#term_dgwnsp_1">dgwnsp</a> :
</li>
<li>
<a href="#term_dnsp_1">dnsp</a> :
</li>
<li>
<a href="#term_dsp_1">dsp</a> : Dyadwise shared partners
</li>
<li>
<a href="#term_dyadcov_1">dyadcov</a> : Dyadic covariate
</li>
<li>
<a href="#term_edgecov_1">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edges_1">edges</a> : Edges
</li>
<li>
<a href="#term_esp_1">esp</a> : Edgewise shared partners
</li>
<li>
<a href="#term_gwb1degree_1">gwb1degree</a> : Geometrically weighted degree distribution for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_gwb1dsp_1">gwb1dsp</a> : Geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition
</li>
<li>
<a href="#term_gwb2degree_1">gwb2degree</a> : Geometrically weighted degree distribution for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_gwb2dsp_1">gwb2dsp</a> : Geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition
</li>
<li>
<a href="#term_gwdegree_1">gwdegree</a> : Geometrically weighted degree distribution
</li>
<li>
<a href="#term_gwdsp_1">gwdsp</a> : Geometrically weighted dyadwise shared partner distribution
</li>
<li>
<a href="#term_gwesp_1">gwesp</a> : Geometrically weighted edgewise shared partner distribution
</li>
<li>
<a href="#term_gwidegree_1">gwidegree</a> : Geometrically weighted in-degree distribution
</li>
<li>
<a href="#term_gwnsp_1">gwnsp</a> : Geometrically weighted nonedgewise shared partner distribution
</li>
<li>
<a href="#term_gwodegree_1">gwodegree</a> : Geometrically weighted out-degree distribution
</li>
<li>
<a href="#term_hamming_1">hamming</a> : Hamming distance
</li>
<li>
<a href="#term_idegrange_1">idegrange</a> : In-degree range
</li>
<li>
<a href="#term_idegree_1">idegree</a> : In-degree
</li>
<li>
<a href="#term_idegree1.5_1">idegree1.5</a> : In-degree to the 3/2 power
</li>
<li>
<a href="#term_idegreepopularity_1">idegreepopularity</a> : In-degree popularity (deprecated)
</li>
<li>
<a href="#term_intransitive_1">intransitive</a> : Intransitive triads
</li>
<li>
<a href="#term_intransitive_1">intransitive</a> : Intransitive triads
</li>
<li>
<a href="#term_isolatededges_1">isolatededges</a> : Isolated edges
</li>
<li>
<a href="#term_isolates_1">isolates</a> : Isolates
</li>
<li>
<a href="#term_istar_1">istar</a> : In-stars
</li>
<li>
<a href="#term_kstar_1">kstar</a> : k-Stars
</li>
<li>
<a href="#term_localtriangle_1">localtriangle</a> : Triangles within neighborhoods
</li>
<li>
<a href="#term_m2star_1">m2star</a> : Mixed 2-stars, a.k.a 2-paths
</li>
<li>
<a href="#term_meandeg_1">meandeg</a> : Mean vertex degree
</li>
<li>
<a href="#term_mm_1">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mutual_1">mutual</a> : Mutuality
</li>
<li>
<a href="#term_nearsimmelian_1">nearsimmelian</a> : Near simmelian triads
</li>
<li>
<a href="#term_nodecov_1">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodemain_3">nodemain</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodefactor_1">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodeicov_1">nodeicov</a> : Main effect of a covariate for in-edges
</li>
<li>
<a href="#term_nodeifactor_1">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodematch_1">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_match_3">match</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodemix_1">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodeocov_1">nodeocov</a> : Main effect of a covariate for out-edges
</li>
<li>
<a href="#term_nodeofactor_1">nodeofactor</a> : Factor attribute effect for out-edges
</li>
<li>
<a href="#term_nsp_1">nsp</a> : Nonedgewise shared partners
</li>
<li>
<a href="#term_odegrange_1">odegrange</a> : Out-degree range
</li>
<li>
<a href="#term_odegree_1">odegree</a> : Out-degree
</li>
<li>
<a href="#term_odegree1.5_1">odegree1.5</a> : Out-degree to the 3/2 power
</li>
<li>
<a href="#term_odegreepopularity_1">odegreepopularity</a> : Out-degree popularity (deprecated)
</li>
<li>
<a href="#term_opentriad_1">opentriad</a> : Open triads
</li>
<li>
<a href="#term_ostar_1">ostar</a> : k-Outstars
</li>
<li>
<a href="#term_receiver_1">receiver</a> : Receiver effect
</li>
<li>
<a href="#term_sender_1">sender</a> : Sender effect
</li>
<li>
<a href="#term_simmelian_1">simmelian</a> : Simmelian triads
</li>
<li>
<a href="#term_simmelianties_1">simmelianties</a> : Ties in simmelian triads
</li>
<li>
<a href="#term_smalldiff_1">smalldiff</a> : Number of ties between actors with similar (but not necessarily identical) attribute values
</li>
<li>
<a href="#term_sociality_1">sociality</a> : Undirected degree
</li>
<li>
<a href="#term_threetrail_1">threetrail</a> : Three-trails
</li>
<li>
<a href="#term_transitive_1">transitive</a> : Transitive triads
</li>
<li>
<a href="#term_transitiveties_1">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_triadcensus_1">triadcensus</a> : Triad census
</li>
<li>
<a href="#term_triangle_1">triangle</a> : Triangles
</li>
<li>
<a href="#term_tripercent_1">tripercent</a> : Triangle percentage
</li>
<li>
<a href="#term_ttriple_1">ttriple</a> : Transitive triples
</li>
<li>
<a href="#term_ttriad_2">ttriad</a> : Transitive triples
</li>
<li>
<a href="#term_twopath_1">twopath</a> : 2-Paths
</li>
</ul>
<h3>
<a id="cat_directed">directed</a>
</h3>
<ul>
<li>
<a href="#term_Symmetrize_1">Symmetrize</a> : Evaluation on symmetrized (undirected) networ
</li>
<li>
<a href="#term_absdiff_1">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiff_2">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiffcat_1">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_absdiffcat_2">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_asymmetric_1">asymmetric</a> : Asymmetric dyads
</li>
<li>
<a href="#term_atleast_1">atleast</a> : Number of dyads with values greater than or equal to a threshol
</li>
<li>
<a href="#term_atmost_1">atmost</a> : Number of dyads with values less than or equal to a threshol
</li>
<li>
<a href="#term_attrcov_1">attrcov</a> : Edge covariate by attribute pairing
</li>
<li>
<a href="#term_balance_1">balance</a> : Balanced triads
</li>
<li>
<a href="#term_ctriple_1">ctriple</a> : Cyclic triples
</li>
<li>
<a href="#term_ctriad_2">ctriad</a> : Cyclic triples
</li>
<li>
<a href="#term_cycle_1">cycle</a> : k-Cycle Census
</li>
<li>
<a href="#term_cyclicalties_1">cyclicalties</a> : Cyclical ties
</li>
<li>
<a href="#term_cyclicalties_2">cyclicalties</a> : Cyclical ties
</li>
<li>
<a href="#term_cyclicalweights_1">cyclicalweights</a> : Cyclical weights
</li>
<li>
<a href="#term_ddsp_1">ddsp</a> :
</li>
<li>
<a href="#term_density_1">density</a> : Density
</li>
<li>
<a href="#term_diff_1">diff</a> : Difference
</li>
<li>
<a href="#term_diff_2">diff</a> : Difference
</li>
<li>
<a href="#term_desp_1">desp</a> :
</li>
<li>
<a href="#term_dgwdsp_1">dgwdsp</a> :
</li>
<li>
<a href="#term_dgwesp_1">dgwesp</a> :
</li>
<li>
<a href="#term_dgwnsp_1">dgwnsp</a> :
</li>
<li>
<a href="#term_dnsp_1">dnsp</a> :
</li>
<li>
<a href="#term_dsp_1">dsp</a> : Dyadwise shared partners
</li>
<li>
<a href="#term_dyadcov_1">dyadcov</a> : Dyadic covariate
</li>
<li>
<a href="#term_edgecov_1">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edgecov_2">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edges_1">edges</a> : Edges
</li>
<li>
<a href="#term_nonzero_2">nonzero</a> : Edges
</li>
<li>
<a href="#term_esp_1">esp</a> : Edgewise shared partners
</li>
<li>
<a href="#term_equalto_1">equalto</a> : Number of dyads with values equal to a specific value (within tolerance)
</li>
<li>
<a href="#term_greaterthan_1">greaterthan</a> : Number of dyads with values strictly greater than a threshold
</li>
<li>
<a href="#term_gwdsp_1">gwdsp</a> : Geometrically weighted dyadwise shared partner distribution
</li>
<li>
<a href="#term_gwesp_1">gwesp</a> : Geometrically weighted edgewise shared partner distribution
</li>
<li>
<a href="#term_gwidegree_1">gwidegree</a> : Geometrically weighted in-degree distribution
</li>
<li>
<a href="#term_gwnsp_1">gwnsp</a> : Geometrically weighted nonedgewise shared partner distribution
</li>
<li>
<a href="#term_gwodegree_1">gwodegree</a> : Geometrically weighted out-degree distribution
</li>
<li>
<a href="#term_hamming_1">hamming</a> : Hamming distance
</li>
<li>
<a href="#term_idegrange_1">idegrange</a> : In-degree range
</li>
<li>
<a href="#term_idegree_1">idegree</a> : In-degree
</li>
<li>
<a href="#term_idegree1.5_1">idegree1.5</a> : In-degree to the 3/2 power
</li>
<li>
<a href="#term_idegreepopularity_1">idegreepopularity</a> : In-degree popularity (deprecated)
</li>
<li>
<a href="#term_ininterval_1">ininterval</a> : Number of dyads whose values are in an interva
</li>
<li>
<a href="#term_intransitive_1">intransitive</a> : Intransitive triads
</li>
<li>
<a href="#term_intransitive_1">intransitive</a> : Intransitive triads
</li>
<li>
<a href="#term_isolates_1">isolates</a> : Isolates
</li>
<li>
<a href="#term_istar_1">istar</a> : In-stars
</li>
<li>
<a href="#term_smallerthan_1">smallerthan</a> : Number of dyads with values strictly smaller than a threshold
</li>
<li>
<a href="#term_localtriangle_1">localtriangle</a> : Triangles within neighborhoods
</li>
<li>
<a href="#term_m2star_1">m2star</a> : Mixed 2-stars, a.k.a 2-paths
</li>
<li>
<a href="#term_meandeg_1">meandeg</a> : Mean vertex degree
</li>
<li>
<a href="#term_mm_1">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mm_2">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mutual_1">mutual</a> : Mutuality
</li>
<li>
<a href="#term_mutual_2">mutual</a> : Mutuality
</li>
<li>
<a href="#term_nearsimmelian_1">nearsimmelian</a> : Near simmelian triads
</li>
<li>
<a href="#term_nodecov_1">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodecov_2">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodemain_3">nodemain</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodecovar_1">nodecovar</a> :
</li>
<li>
<a href="#term_nodecovar_1">nodecovar</a> : Uncentered covariance of dyad values incident on each actor
</li>
<li>
<a href="#term_nodefactor_1">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodefactor_2">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodeicov_1">nodeicov</a> : Main effect of a covariate for in-edges
</li>
<li>
<a href="#term_nodeicov_2">nodeicov</a> : Main effect of a covariate for in-edges
</li>
<li>
<a href="#term_nodeicovar_1">nodeicovar</a> :
</li>
<li>
<a href="#term_nodeifactor_1">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodeifactor_2">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodematch_1">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodematch_2">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_match_3">match</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodemix_1">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodemix_2">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodeocov_1">nodeocov</a> : Main effect of a covariate for out-edges
</li>
<li>
<a href="#term_nodeocov_2">nodeocov</a> : Main effect of a covariate for out-edges
</li>
<li>
<a href="#term_nodeocovar_1">nodeocovar</a> :
</li>
<li>
<a href="#term_nodeofactor_1">nodeofactor</a> : Factor attribute effect for out-edges
</li>
<li>
<a href="#term_nodeofactor_2">nodeofactor</a> : Factor attribute effect for out-edges
</li>
<li>
<a href="#term_nsp_1">nsp</a> : Nonedgewise shared partners
</li>
<li>
<a href="#term_odegrange_1">odegrange</a> : Out-degree range
</li>
<li>
<a href="#term_odegree_1">odegree</a> : Out-degree
</li>
<li>
<a href="#term_odegree1.5_1">odegree1.5</a> : Out-degree to the 3/2 power
</li>
<li>
<a href="#term_odegreepopularity_1">odegreepopularity</a> : Out-degree popularity (deprecated)
</li>
<li>
<a href="#term_ostar_1">ostar</a> : k-Outstars
</li>
<li>
<a href="#term_receiver_1">receiver</a> : Receiver effect
</li>
<li>
<a href="#term_receiver_2">receiver</a> : Receiver effect
</li>
<li>
<a href="#term_sender_1">sender</a> : Sender effect
</li>
<li>
<a href="#term_sender_2">sender</a> : Sender effect
</li>
<li>
<a href="#term_simmelian_1">simmelian</a> : Simmelian triads
</li>
<li>
<a href="#term_simmelianties_1">simmelianties</a> : Ties in simmelian triads
</li>
<li>
<a href="#term_smalldiff_1">smalldiff</a> : Number of ties between actors with similar (but not necessarily identical) attribute values
</li>
<li>
<a href="#term_sum_1">sum</a> : Sum of dyad values (optionally taken to a power)
</li>
<li>
<a href="#term_threetrail_1">threetrail</a> : Three-trails
</li>
<li>
<a href="#term_transitive_1">transitive</a> : Transitive triads
</li>
<li>
<a href="#term_transitiveties_1">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_transitiveties_2">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_transitiveweights_1">transitiveweights</a> : Transitive weights
</li>
<li>
<a href="#term_triadcensus_1">triadcensus</a> : Triad census
</li>
<li>
<a href="#term_triangle_1">triangle</a> : Triangles
</li>
<li>
<a href="#term_ttriple_1">ttriple</a> : Transitive triples
</li>
<li>
<a href="#term_ttriad_2">ttriad</a> : Transitive triples
</li>
<li>
<a href="#term_twopath_1">twopath</a> : 2-Paths
</li>
</ul>
<h3>
<a id="cat_dyad-independent">dyad-independent</a>
</h3>
<ul>
<li>
<a href="#term_absdiff_1">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiff_2">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiffcat_1">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_absdiffcat_2">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_asymmetric_1">asymmetric</a> : Asymmetric dyads
</li>
<li>
<a href="#term_atleast_1">atleast</a> : Number of dyads with values greater than or equal to a threshol
</li>
<li>
<a href="#term_atmost_1">atmost</a> : Number of dyads with values less than or equal to a threshol
</li>
<li>
<a href="#term_attrcov_1">attrcov</a> : Edge covariate by attribute pairing
</li>
<li>
<a href="#term_b1cov_1">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1cov_2">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_1">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_2">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1nodematch_1">b1nodematch</a> : Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1sociality_1">b1sociality</a> : Degree
</li>
<li>
<a href="#term_b1sociality_2">b1sociality</a> : Degree
</li>
<li>
<a href="#term_b2cov_1">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_2">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_1">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_2">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2nodematch_1">b2nodematch</a> : Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2sociality_1">b2sociality</a> : Degree
</li>
<li>
<a href="#term_b2sociality_2">b2sociality</a> : Degree
</li>
<li>
<a href="#term_density_1">density</a> : Density
</li>
<li>
<a href="#term_diff_1">diff</a> : Difference
</li>
<li>
<a href="#term_diff_2">diff</a> : Difference
</li>
<li>
<a href="#term_dyadcov_1">dyadcov</a> : Dyadic covariate
</li>
<li>
<a href="#term_edgecov_1">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edgecov_2">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edges_1">edges</a> : Edges
</li>
<li>
<a href="#term_nonzero_2">nonzero</a> : Edges
</li>
<li>
<a href="#term_equalto_1">equalto</a> : Number of dyads with values equal to a specific value (within tolerance)
</li>
<li>
<a href="#term_greaterthan_1">greaterthan</a> : Number of dyads with values strictly greater than a threshold
</li>
<li>
<a href="#term_hamming_1">hamming</a> : Hamming distance
</li>
<li>
<a href="#term_ininterval_1">ininterval</a> : Number of dyads whose values are in an interva
</li>
<li>
<a href="#term_smallerthan_1">smallerthan</a> : Number of dyads with values strictly smaller than a threshold
</li>
<li>
<a href="#term_meandeg_1">meandeg</a> : Mean vertex degree
</li>
<li>
<a href="#term_mm_1">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mm_2">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_nodecov_1">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodecov_2">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodefactor_1">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodefactor_2">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodeifactor_1">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodeifactor_2">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodematch_1">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodematch_2">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_match_3">match</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodemix_1">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodemix_2">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodeocov_1">nodeocov</a> : Main effect of a covariate for out-edges
</li>
<li>
<a href="#term_nodeocov_2">nodeocov</a> : Main effect of a covariate for out-edges
</li>
<li>
<a href="#term_nodeofactor_1">nodeofactor</a> : Factor attribute effect for out-edges
</li>
<li>
<a href="#term_nodeofactor_2">nodeofactor</a> : Factor attribute effect for out-edges
</li>
<li>
<a href="#term_receiver_1">receiver</a> : Receiver effect
</li>
<li>
<a href="#term_receiver_2">receiver</a> : Receiver effect
</li>
<li>
<a href="#term_sender_1">sender</a> : Sender effect
</li>
<li>
<a href="#term_sender_2">sender</a> : Sender effect
</li>
<li>
<a href="#term_smalldiff_1">smalldiff</a> : Number of ties between actors with similar (but not necessarily identical) attribute values
</li>
<li>
<a href="#term_sociality_1">sociality</a> : Undirected degree
</li>
<li>
<a href="#term_sociality_2">sociality</a> : Undirected degree
</li>
</ul>
<h3>
<a id="cat_frequently-used">frequently-used</a>
</h3>
<ul>
<li>
<a href="#term_absdiff_1">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_b1cov_1">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1cov_2">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1degree_1">b1degree</a> : Degree for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_1">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_2">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1nodematch_1">b1nodematch</a> : Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2concurrent_1">b2concurrent</a> : Concurrent node count for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_1">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_2">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2degree_1">b2degree</a> : Degree for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_1">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_2">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2nodematch_1">b2nodematch</a> : Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_degree_1">degree</a> : Degree
</li>
<li>
<a href="#term_diff_1">diff</a> : Difference
</li>
<li>
<a href="#term_edgecov_1">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edges_1">edges</a> : Edges
</li>
<li>
<a href="#term_gwdegree_1">gwdegree</a> : Geometrically weighted degree distribution
</li>
<li>
<a href="#term_gwesp_1">gwesp</a> : Geometrically weighted edgewise shared partner distribution
</li>
<li>
<a href="#term_idegree_1">idegree</a> : In-degree
</li>
<li>
<a href="#term_isolates_1">isolates</a> : Isolates
</li>
<li>
<a href="#term_mm_1">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mm_2">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mutual_1">mutual</a> : Mutuality
</li>
<li>
<a href="#term_nodecov_1">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodefactor_1">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodeicov_1">nodeicov</a> : Main effect of a covariate for in-edges
</li>
<li>
<a href="#term_nodeifactor_1">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodematch_1">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodemix_1">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_odegree_1">odegree</a> : Out-degree
</li>
<li>
<a href="#term_triangle_1">triangle</a> : Triangles
</li>
</ul>
<h3>
<a id="cat_undirected">undirected</a>
</h3>
<ul>
<li>
<a href="#term_absdiff_1">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiff_2">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiffcat_1">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_absdiffcat_2">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_altkstar_1">altkstar</a> : Alternating k-star
</li>
<li>
<a href="#term_atleast_1">atleast</a> : Number of dyads with values greater than or equal to a threshol
</li>
<li>
<a href="#term_atmost_1">atmost</a> : Number of dyads with values less than or equal to a threshol
</li>
<li>
<a href="#term_attrcov_1">attrcov</a> : Edge covariate by attribute pairing
</li>
<li>
<a href="#term_b1concurrent_1">b1concurrent</a> : Concurrent node count for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1cov_1">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1cov_2">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1degrange_1">b1degrange</a> : Degree range for the first mode in a bipartite (a.k.a. two-mode) network
</li>
<li>
<a href="#term_b1degree_1">b1degree</a> : Degree for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1dsp_1">b1dsp</a> : Dyadwise shared partners for dyads in the first bipartition
</li>
<li>
<a href="#term_b1factor_1">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_2">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1mindegree_1">b1mindegree</a> : Minimum degree for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1nodematch_1">b1nodematch</a> : Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1sociality_1">b1sociality</a> : Degree
</li>
<li>
<a href="#term_b1sociality_2">b1sociality</a> : Degree
</li>
<li>
<a href="#term_b1star_1">b1star</a> : k-Stars for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1starmix_1">b1starmix</a> : Mixing matrix for k-stars centered on the first mode of a bipartite network
</li>
<li>
<a href="#term_b1twostar_1">b1twostar</a> : Two-star census for central nodes centered on the first mode of a bipartite network
</li>
<li>
<a href="#term_b2concurrent_1">b2concurrent</a> : Concurrent node count for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_1">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_2">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2degrange_1">b2degrange</a> : Degree range for the second mode in a bipartite (a.k.a. two-mode) network
</li>
<li>
<a href="#term_b2degree_1">b2degree</a> : Degree for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2dsp_1">b2dsp</a> : Dyadwise shared partners for dyads in the second bipartition
</li>
<li>
<a href="#term_b2factor_1">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_2">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2mindegree_1">b2mindegree</a> : Minimum degree for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2nodematch_1">b2nodematch</a> : Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2sociality_1">b2sociality</a> : Degree
</li>
<li>
<a href="#term_b2sociality_2">b2sociality</a> : Degree
</li>
<li>
<a href="#term_b2star_1">b2star</a> : k-Stars for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2starmix_1">b2starmix</a> : Mixing matrix for k-stars centered on the second mode of a bipartite network
</li>
<li>
<a href="#term_b2twostar_1">b2twostar</a> : Two-star census for central nodes centered on the second mode of a bipartite network
</li>
<li>
<a href="#term_balance_1">balance</a> : Balanced triads
</li>
<li>
<a href="#term_coincidence_1">coincidence</a> : Coincident node count for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_concurrent_1">concurrent</a> : Concurrent node count
</li>
<li>
<a href="#term_concurrentties_1">concurrentties</a> : Concurrent tie count
</li>
<li>
<a href="#term_cycle_1">cycle</a> : k-Cycle Census
</li>
<li>
<a href="#term_cyclicalties_1">cyclicalties</a> : Cyclical ties
</li>
<li>
<a href="#term_cyclicalties_2">cyclicalties</a> : Cyclical ties
</li>
<li>
<a href="#term_cyclicalweights_1">cyclicalweights</a> : Cyclical weights
</li>
<li>
<a href="#term_degrange_1">degrange</a> : Degree range
</li>
<li>
<a href="#term_degree_1">degree</a> : Degree
</li>
<li>
<a href="#term_degree1.5_1">degree1.5</a> : Degree to the 3/2 power
</li>
<li>
<a href="#term_degreepopularity_1">degreepopularity</a> : Degree popularity (deprecated)
</li>
<li>
<a href="#term_degcrossprod_1">degcrossprod</a> : Degree Cross-Product
</li>
<li>
<a href="#term_degcor_1">degcor</a> : Degree Correlation
</li>
<li>
<a href="#term_density_1">density</a> : Density
</li>
<li>
<a href="#term_diff_1">diff</a> : Difference
</li>
<li>
<a href="#term_diff_2">diff</a> : Difference
</li>
<li>
<a href="#term_dsp_1">dsp</a> : Dyadwise shared partners
</li>
<li>
<a href="#term_dyadcov_1">dyadcov</a> : Dyadic covariate
</li>
<li>
<a href="#term_edgecov_1">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edgecov_2">edgecov</a> : Edge covariate
</li>
<li>
<a href="#term_edges_1">edges</a> : Edges
</li>
<li>
<a href="#term_nonzero_2">nonzero</a> : Edges
</li>
<li>
<a href="#term_esp_1">esp</a> : Edgewise shared partners
</li>
<li>
<a href="#term_equalto_1">equalto</a> : Number of dyads with values equal to a specific value (within tolerance)
</li>
<li>
<a href="#term_greaterthan_1">greaterthan</a> : Number of dyads with values strictly greater than a threshold
</li>
<li>
<a href="#term_gwb1degree_1">gwb1degree</a> : Geometrically weighted degree distribution for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_gwb1dsp_1">gwb1dsp</a> : Geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition
</li>
<li>
<a href="#term_gwb2degree_1">gwb2degree</a> : Geometrically weighted degree distribution for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_gwb2dsp_1">gwb2dsp</a> : Geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition
</li>
<li>
<a href="#term_gwdegree_1">gwdegree</a> : Geometrically weighted degree distribution
</li>
<li>
<a href="#term_gwdsp_1">gwdsp</a> : Geometrically weighted dyadwise shared partner distribution
</li>
<li>
<a href="#term_gwesp_1">gwesp</a> : Geometrically weighted edgewise shared partner distribution
</li>
<li>
<a href="#term_gwnsp_1">gwnsp</a> : Geometrically weighted nonedgewise shared partner distribution
</li>
<li>
<a href="#term_hamming_1">hamming</a> : Hamming distance
</li>
<li>
<a href="#term_ininterval_1">ininterval</a> : Number of dyads whose values are in an interva
</li>
<li>
<a href="#term_isolatededges_1">isolatededges</a> : Isolated edges
</li>
<li>
<a href="#term_isolates_1">isolates</a> : Isolates
</li>
<li>
<a href="#term_kstar_1">kstar</a> : k-Stars
</li>
<li>
<a href="#term_smallerthan_1">smallerthan</a> : Number of dyads with values strictly smaller than a threshold
</li>
<li>
<a href="#term_localtriangle_1">localtriangle</a> : Triangles within neighborhoods
</li>
<li>
<a href="#term_meandeg_1">meandeg</a> : Mean vertex degree
</li>
<li>
<a href="#term_mm_1">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mm_2">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_nodecov_1">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodecov_2">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodemain_3">nodemain</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodecovar_1">nodecovar</a> : Uncentered covariance of dyad values incident on each actor
</li>
<li>
<a href="#term_nodefactor_1">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodefactor_2">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodematch_1">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodematch_2">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_match_3">match</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodemix_1">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodemix_2">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nsp_1">nsp</a> : Nonedgewise shared partners
</li>
<li>
<a href="#term_opentriad_1">opentriad</a> : Open triads
</li>
<li>
<a href="#term_smalldiff_1">smalldiff</a> : Number of ties between actors with similar (but not necessarily identical) attribute values
</li>
<li>
<a href="#term_sociality_1">sociality</a> : Undirected degree
</li>
<li>
<a href="#term_sociality_2">sociality</a> : Undirected degree
</li>
<li>
<a href="#term_sum_1">sum</a> : Sum of dyad values (optionally taken to a power)
</li>
<li>
<a href="#term_threetrail_1">threetrail</a> : Three-trails
</li>
<li>
<a href="#term_transitiveties_1">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_transitiveties_2">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_transitiveweights_1">transitiveweights</a> : Transitive weights
</li>
<li>
<a href="#term_triadcensus_1">triadcensus</a> : Triad census
</li>
<li>
<a href="#term_triangle_1">triangle</a> : Triangles
</li>
<li>
<a href="#term_tripercent_1">tripercent</a> : Triangle percentage
</li>
<li>
<a href="#term_twopath_1">twopath</a> : 2-Paths
</li>
</ul>
<h3>
<a id="cat_quantitative nodal attribute">quantitative nodal attribute</a>
</h3>
<ul>
<li>
<a href="#term_absdiff_1">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_absdiff_2">absdiff</a> : Absolute difference
</li>
<li>
<a href="#term_b1cov_1">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1cov_2">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_1">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_2">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_diff_1">diff</a> : Difference
</li>
<li>
<a href="#term_diff_2">diff</a> : Difference
</li>
<li>
<a href="#term_nodecov_1">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodecov_2">nodecov</a> : Main effect of a covariate
</li>
<li>
<a href="#term_nodecovar_1">nodecovar</a> : Uncentered covariance of dyad values incident on each actor
</li>
<li>
<a href="#term_nodeicov_1">nodeicov</a> : Main effect of a covariate for in-edges
</li>
<li>
<a href="#term_nodeicov_2">nodeicov</a> : Main effect of a covariate for in-edges
</li>
<li>
<a href="#term_nodeocov_1">nodeocov</a> : Main effect of a covariate for out-edges
</li>
<li>
<a href="#term_smalldiff_1">smalldiff</a> : Number of ties between actors with similar (but not necessarily identical) attribute values
</li>
</ul>
<h3>
<a id="cat_categorical nodal attribute">categorical nodal attribute</a>
</h3>
<ul>
<li>
<a href="#term_absdiffcat_1">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_absdiffcat_2">absdiffcat</a> : Categorical absolute difference
</li>
<li>
<a href="#term_altkstar_1">altkstar</a> : Alternating k-star
</li>
<li>
<a href="#term_b1concurrent_1">b1concurrent</a> : Concurrent node count for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1degree_1">b1degree</a> : Degree for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_1">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_2">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1nodematch_1">b1nodematch</a> : Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1star_1">b1star</a> : k-Stars for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1starmix_1">b1starmix</a> : Mixing matrix for k-stars centered on the first mode of a bipartite network
</li>
<li>
<a href="#term_b1twostar_1">b1twostar</a> : Two-star census for central nodes centered on the first mode of a bipartite network
</li>
<li>
<a href="#term_b2degree_1">b2degree</a> : Degree for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_1">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_2">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2nodematch_1">b2nodematch</a> : Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2star_1">b2star</a> : k-Stars for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2starmix_1">b2starmix</a> : Mixing matrix for k-stars centered on the second mode of a bipartite network
</li>
<li>
<a href="#term_b2twostar_1">b2twostar</a> : Two-star census for central nodes centered on the second mode of a bipartite network
</li>
<li>
<a href="#term_concurrent_1">concurrent</a> : Concurrent node count
</li>
<li>
<a href="#term_concurrentties_1">concurrentties</a> : Concurrent tie count
</li>
<li>
<a href="#term_ctriple_1">ctriple</a> : Cyclic triples
</li>
<li>
<a href="#term_ctriad_2">ctriad</a> : Cyclic triples
</li>
<li>
<a href="#term_degrange_1">degrange</a> : Degree range
</li>
<li>
<a href="#term_degree_1">degree</a> : Degree
</li>
<li>
<a href="#term_dyadcov_1">dyadcov</a> : Dyadic covariate
</li>
<li>
<a href="#term_idegrange_1">idegrange</a> : In-degree range
</li>
<li>
<a href="#term_idegree_1">idegree</a> : In-degree
</li>
<li>
<a href="#term_istar_1">istar</a> : In-stars
</li>
<li>
<a href="#term_kstar_1">kstar</a> : k-Stars
</li>
<li>
<a href="#term_mm_1">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_mm_2">mm</a> : Mixing matrix cells and margins
</li>
<li>
<a href="#term_nodefactor_1">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodefactor_2">nodefactor</a> : Factor attribute effect
</li>
<li>
<a href="#term_nodeifactor_1">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodeifactor_2">nodeifactor</a> : Factor attribute effect for in-edges
</li>
<li>
<a href="#term_nodematch_1">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodematch_2">nodematch</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_match_3">match</a> : Uniform homophily and differential homophily
</li>
<li>
<a href="#term_nodemix_1">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodemix_2">nodemix</a> : Nodal attribute mixing
</li>
<li>
<a href="#term_nodeofactor_1">nodeofactor</a> : Factor attribute effect for out-edges
</li>
<li>
<a href="#term_nodeofactor_2">nodeofactor</a> : Factor attribute effect for out-edges
</li>
<li>
<a href="#term_odegrange_1">odegrange</a> : Out-degree range
</li>
<li>
<a href="#term_odegree_1">odegree</a> : Out-degree
</li>
<li>
<a href="#term_ostar_1">ostar</a> : k-Outstars
</li>
<li>
<a href="#term_sociality_1">sociality</a> : Undirected degree
</li>
<li>
<a href="#term_sociality_2">sociality</a> : Undirected degree
</li>
<li>
<a href="#term_transitiveties_1">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_triangle_1">triangle</a> : Triangles
</li>
<li>
<a href="#term_tripercent_1">tripercent</a> : Triangle percentage
</li>
<li>
<a href="#term_ttriple_1">ttriple</a> : Transitive triples
</li>
<li>
<a href="#term_ttriad_2">ttriad</a> : Transitive triples
</li>
</ul>
<h3>
<a id="cat_curved">curved</a>
</h3>
<ul>
<li>
<a href="#term_altkstar_1">altkstar</a> : Alternating k-star
</li>
<li>
<a href="#term_gwb1degree_1">gwb1degree</a> : Geometrically weighted degree distribution for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_gwb1dsp_1">gwb1dsp</a> : Geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition
</li>
<li>
<a href="#term_gwb2degree_1">gwb2degree</a> : Geometrically weighted degree distribution for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_gwb2dsp_1">gwb2dsp</a> : Geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition
</li>
<li>
<a href="#term_gwdegree_1">gwdegree</a> : Geometrically weighted degree distribution
</li>
<li>
<a href="#term_gwdsp_1">gwdsp</a> : Geometrically weighted dyadwise shared partner distribution
</li>
<li>
<a href="#term_gwesp_1">gwesp</a> : Geometrically weighted edgewise shared partner distribution
</li>
<li>
<a href="#term_gwidegree_1">gwidegree</a> : Geometrically weighted in-degree distribution
</li>
<li>
<a href="#term_gwnsp_1">gwnsp</a> : Geometrically weighted nonedgewise shared partner distribution
</li>
<li>
<a href="#term_gwodegree_1">gwodegree</a> : Geometrically weighted out-degree distribution
</li>
</ul>
<h3>
<a id="cat_triad-related">triad-related</a>
</h3>
<ul>
<li>
<a href="#term_asymmetric_1">asymmetric</a> : Asymmetric dyads
</li>
<li>
<a href="#term_balance_1">balance</a> : Balanced triads
</li>
<li>
<a href="#term_ctriple_1">ctriple</a> : Cyclic triples
</li>
<li>
<a href="#term_ctriad_2">ctriad</a> : Cyclic triples
</li>
<li>
<a href="#term_intransitive_1">intransitive</a> : Intransitive triads
</li>
<li>
<a href="#term_intransitive_1">intransitive</a> : Intransitive triads
</li>
<li>
<a href="#term_localtriangle_1">localtriangle</a> : Triangles within neighborhoods
</li>
<li>
<a href="#term_nearsimmelian_1">nearsimmelian</a> : Near simmelian triads
</li>
<li>
<a href="#term_opentriad_1">opentriad</a> : Open triads
</li>
<li>
<a href="#term_simmelian_1">simmelian</a> : Simmelian triads
</li>
<li>
<a href="#term_simmelianties_1">simmelianties</a> : Ties in simmelian triads
</li>
<li>
<a href="#term_transitive_1">transitive</a> : Transitive triads
</li>
<li>
<a href="#term_transitiveties_1">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_transitiveties_2">transitiveties</a> : Transitive ties
</li>
<li>
<a href="#term_transitiveweights_1">transitiveweights</a> : Transitive weights
</li>
<li>
<a href="#term_triadcensus_1">triadcensus</a> : Triad census
</li>
<li>
<a href="#term_triangle_1">triangle</a> : Triangles
</li>
<li>
<a href="#term_tripercent_1">tripercent</a> : Triangle percentage
</li>
<li>
<a href="#term_ttriple_1">ttriple</a> : Transitive triples
</li>
<li>
<a href="#term_ttriad_2">ttriad</a> : Transitive triples
</li>
</ul>
<h3>
<a id="cat_bipartite">bipartite</a>
</h3>
<ul>
<li>
<a href="#term_b1concurrent_1">b1concurrent</a> : Concurrent node count for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1cov_1">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1cov_2">b1cov</a> : Main effect of a covariate for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1degrange_1">b1degrange</a> : Degree range for the first mode in a bipartite (a.k.a. two-mode) network
</li>
<li>
<a href="#term_b1degree_1">b1degree</a> : Degree for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1dsp_1">b1dsp</a> : Dyadwise shared partners for dyads in the first bipartition
</li>
<li>
<a href="#term_b1factor_1">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1factor_2">b1factor</a> : Factor attribute effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1mindegree_1">b1mindegree</a> : Minimum degree for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1nodematch_1">b1nodematch</a> : Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1sociality_1">b1sociality</a> : Degree
</li>
<li>
<a href="#term_b1sociality_2">b1sociality</a> : Degree
</li>
<li>
<a href="#term_b1star_1">b1star</a> : k-Stars for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b1starmix_1">b1starmix</a> : Mixing matrix for k-stars centered on the first mode of a bipartite network
</li>
<li>
<a href="#term_b1twostar_1">b1twostar</a> : Two-star census for central nodes centered on the first mode of a bipartite network
</li>
<li>
<a href="#term_b2concurrent_1">b2concurrent</a> : Concurrent node count for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_1">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2cov_2">b2cov</a> : Main effect of a covariate for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2degrange_1">b2degrange</a> : Degree range for the second mode in a bipartite (a.k.a. two-mode) network
</li>
<li>
<a href="#term_b2degree_1">b2degree</a> : Degree for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2dsp_1">b2dsp</a> : Dyadwise shared partners for dyads in the second bipartition
</li>
<li>
<a href="#term_b2factor_1">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2factor_2">b2factor</a> : Factor attribute effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2mindegree_1">b2mindegree</a> : Minimum degree for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2nodematch_1">b2nodematch</a> : Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2sociality_1">b2sociality</a> : Degree
</li>
<li>
<a href="#term_b2sociality_2">b2sociality</a> : Degree
</li>
<li>
<a href="#term_b2star_1">b2star</a> : k-Stars for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_b2starmix_1">b2starmix</a> : Mixing matrix for k-stars centered on the second mode of a bipartite network
</li>
<li>
<a href="#term_b2twostar_1">b2twostar</a> : Two-star census for central nodes centered on the second mode of a bipartite network
</li>
<li>
<a href="#term_coincidence_1">coincidence</a> : Coincident node count for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_diff_2">diff</a> : Difference
</li>
<li>
<a href="#term_gwb1degree_1">gwb1degree</a> : Geometrically weighted degree distribution for the first mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_gwb1dsp_1">gwb1dsp</a> : Geometrically weighted dyadwise shared partner distribution for dyads in the first bipartition
</li>
<li>
<a href="#term_gwb2degree_1">gwb2degree</a> : Geometrically weighted degree distribution for the second mode in a bipartite (aka two-mode) network
</li>
<li>
<a href="#term_gwb2dsp_1">gwb2dsp</a> : Geometrically weighted dyadwise shared partner distribution for dyads in the second bipartition
</li>
<li>
<a href="#term_isolatededges_1">isolatededges</a> : Isolated edges
</li>
</ul>
<h3>
<a id="cat_deprecated">deprecated</a>
</h3>
<ul>
<li>
<a href="#term_degreepopularity_1">degreepopularity</a> : Degree popularity (deprecated)
</li>
<li>
<a href="#term_idegreepopularity_1">idegreepopularity</a> : In-degree popularity (deprecated)
</li>
<li>
<a href="#term_odegreepopularity_1">odegreepopularity</a> : Out-degree popularity (deprecated)
</li>
</ul>
<h3>
<a id="cat_non-negative">non-negative</a>
</h3>
<ul>
<li>
<a href="#term_transitiveweights_1">transitiveweights</a> : Transitive weights
</li>
</ul>
<hr />
<p>This documentation was built with..</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">sessionInfo</span>()</span></code></pre></div>
<pre><code>## R version 4.1.0 (2021-05-18)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 11 (bullseye)
## 
## Matrix products: default
## BLAS:   /usr/lib/x86_64-linux-gnu/atlas/libblas.so.3.10.3
## LAPACK: /usr/lib/x86_64-linux-gnu/atlas/liblapack.so.3.10.3
## 
## locale:
##  [1] LC_CTYPE=en_AU.UTF-8      LC_NUMERIC=C             
##  [3] LC_TIME=en_AU.utf8        LC_COLLATE=C             
##  [5] LC_MONETARY=en_AU.utf8    LC_MESSAGES=en_AU.UTF-8  
##  [7] LC_PAPER=en_AU.utf8       LC_NAME=C                
##  [9] LC_ADDRESS=C              LC_TELEPHONE=C           
## [11] LC_MEASUREMENT=en_AU.utf8 LC_IDENTIFICATION=C      
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] ergm_4.1.2     network_1.17.1
## 
## loaded via a namespace (and not attached):
##  [1] DEoptimR_1.0-9           pillar_1.6.1             bslib_0.2.5.1           
##  [4] compiler_4.1.0           jquerylib_0.1.4          tools_4.1.0             
##  [7] digest_0.6.27            jsonlite_1.7.2           evaluate_0.14           
## [10] memoise_2.0.0            lifecycle_1.0.0          tibble_3.1.3            
## [13] rle_0.9.2                lattice_0.20-44          pkgconfig_2.0.3         
## [16] rlang_0.4.11             Matrix_1.3-4             parallel_4.1.0          
## [19] yaml_2.2.1               xfun_0.24                fastmap_1.1.0           
## [22] coda_0.19-4              stringr_1.4.0            knitr_1.33              
## [25] sass_0.4.0               vctrs_0.3.8              trust_0.1-8             
## [28] grid_4.1.0               robustbase_0.93-8        R6_2.5.0                
## [31] fansi_0.5.0              rmarkdown_2.9            purrr_0.3.4             
## [34] magrittr_2.0.1           ellipsis_0.3.2           htmltools_0.5.1.1       
## [37] MASS_7.3-54              utf8_1.2.2               stringi_1.7.3           
## [40] lpSolveAPI_5.5.2.0-17.7  cachem_1.0.5             statnet.common_4.5.0-362
## [43] crayon_1.4.1</code></pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
