<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Pavel N. Krivitsky" />


<title>API for ergm Terms</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">API for <code>ergm</code> Terms</h1>
<h4 class="author">Pavel N. Krivitsky</h4>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">rmarkdown.html_vignette.check_title =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>This document seeks to be the most up-to-date API documentation for
<code>ergm</code> terms. Note that it is not intended to be a tutorial
as much as a description of what inputs and outputs different parts of
the system expect.</p>
</div>
<div id="overview" class="section level1">
<h1>Overview</h1>
<div id="types-of-storage-and-types-of-term" class="section level2">
<h2>Types of storage and types of term</h2>
<p>The storage API defines two types of storage: <em>private
storage</em>, which is attached the <code>ModelTerm</code> structure and
is specific to each <code>ergm</code> term, and <em>public storage</em>,
which is attached to the <code>Model</code> and can be accessed by all
terms.</p>
<p>A <em>statistic</em> is a familiar <code>ergm</code> term like
“<code>edges</code>” or “<code>nodefactor</code>”: it adds at least one
sufficient statistic to the model. Every statistic can have private
storage, and it can read from public storage, but it cannot write to
public storage.</p>
<p>An <em>auxiliary</em> in an <code>ergm</code> term but not an ERGM
term in the mathematical sense: it adds no statistics to the model and
exists only to initialize and maintain public storage to be used by
statistics. It may not be specified on an <code>ergm</code> formula by
the end-user, but only requested by a statistic.</p>
<p>An auxiliary can rely on another auxiliary’s public storage. Note
that circular dependencies are not checked.</p>
</div>
<div id="code-path" class="section level2">
<h2>Code path</h2>
<p>For the purposes of this overview, the following information is
relevant, and is elaborated formally later:</p>
<ul>
<li>Each term has a a pointer <code>void *mtp-&gt;storage</code> to
private storage</li>
<li>Each term has a pointer to an array of pointers to public storage
<code>void **mtp-&gt;aux_storage</code>. (The pointer is to the same
location for all terms of a model.)</li>
<li>Each term has some subset of five functions on the <code>C</code>
side: initializers (<code>i_</code>), updaters (<code>u_</code>), change
stats (<code>c_</code>), difference stats (<code>d_</code>), finalizers
(<code>f_</code>), writers (<code>w_</code>), and “eXtended” functions
(<code>x_</code>).</li>
<li>An <code>InitErgmTerm.</code> function’s output list can have an
additional element, <code>auxiliaries</code>, a one-sided formula.</li>
</ul>
<ol style="list-style-type: decimal">
<li>The user passes a formula to the procedure (<code>ergm</code>,
<code>summary</code>, etc.); this formula may only have statistics.</li>
<li><code>ergm_model()</code> is called.
<ol style="list-style-type: decimal">
<li>It iterates through the formula terms, calling
<code>InitErgmTerm.&lt;NAME&gt;()</code> functions in turn (or
<code>InitWtErgmTerm.&lt;NAME&gt;()</code> for valued ERGMs), adding
their output to the model term list. Some terms include
<code>auxiliaries</code> formulas in their list.</li>
<li><code>call.ErgmTerm()</code> when it finds that a term has requested
auxiliaries, attaches an attribute <code>attr(., &quot;aux.slots&quot;)</code>
containing an integer vector for the model’s own and/or requested
auxiliaries’ positions on the <code>aux_storage</code> vector.</li>
<li>It calls <code>ergm.auxstorage()</code> with the complete model.
<ol style="list-style-type: decimal">
<li>It iterates through initialized model terms, looking at their
<code>auxiliaries</code> element for a one-sided formula listing their
requested auxiliaries.</li>
<li>It iterates through the auxiliary formulas, calling term
initialization on them.</li>
<li>It iterates through the <code>auxiliaries</code> elements of
auxiliary terms and initialises those, etc..</li>
<li>It constructs a list of unique initialized auxilariy terms (that is,
when two or more terms had requested an identical auxiliary).</li>
<li>It inserts the initialized unique auxiliary terms in
<code>model$terms</code> and the index (in the unique list) of the
auxiliary requested by each statistic in the <code>aux.slots</code> of
the requesting statistic.</li>
<li>For auxiliary itself, the first element of <code>aux.slots</code> is
set to the position of the auxiliary itself.</li>
</ol></li>
</ol></li>
<li>The <code>ergm_state</code> is constructed from an edgelist
(<code>state$el</code>), an empty network (<code>state$nw0</code>), a
model (<code>state$model</code>), and (optionally) a proposal
(<code>state$proposal</code>) and a statistics vector
(<code>state$stats</code>).</li>
<li><code>update.ergm_state()</code> is called.
<ol style="list-style-type: decimal">
<li>It iterates through the formula terms, calling
<code>term$ext.encode()</code> (if defined) to construct a vector
<code>state$ext.state</code>. <code>state$ext.flag</code> is set to
reconciled.</li>
</ol></li>
<li>The <code>ergm_state</code> is passed to the <code>C</code>
code.</li>
<li><code>Redgelist2Network()</code> initializes the network.</li>
<li><code>ModelInitialize()</code> is called:
<ol style="list-style-type: decimal">
<li><code>ModelInitialize()</code> initializes all terms (statistic and
auxiliaries), also counting up the number of auxiliaries (distinguished
by having no <code>c_</code>, <code>d_</code>, or <code>s_</code>
functions). A term can export both a <code>c_</code> function and a
<code>d_</code> function. In that case, it is responsible for deleting
one of them when its <code>i_</code> function is called.</li>
<li>It counts up the number of auxiliaries and allocates an array of
<code>void *</code>s, one for each auxiliary. The
<code>mtp-&gt;aux_storage</code> pointer for each term is set to point
to that (one) array.</li>
<li>It assigns <code>attr(model$terms[[i]], &quot;aux.slots&quot;)</code> to
<code>mtp-&gt;aux_slots</code>.</li>
<li>It assigns the <code>ergm_model</code> <code>SEXP</code> to
<code>model-&gt;R</code>, in case it’s needed.</li>
<li>It assigns the <code>ergm_model$terms[[i]]</code> <code>SEXP</code>
to <code>mtp-&gt;R</code>, in case it’s needed.</li>
<li>It calls <code>InitStats()</code>, which calls the initializer
(<code>i_</code> function) of each term or, if not found, an updater
(<code>u_</code> function) with invalid input (i.e., toggle <span class="math inline">\((0,0)\)</span>) is called in case the term
developer prefers a one-function implementation.</li>
</ol>
<ul>
<li>The terms are initialized in reverse order, so auxiliaries are
initialized before the statistics are, and statistics and auxiliaries
can count on their auxiliaries being initialized by the time they are
initialized.</li>
</ul></li>
<li>For each iteration, a proposal is made.
<ol style="list-style-type: decimal">
<li><code>ChangeStats()</code> is called.
<ol style="list-style-type: decimal">
<li>It calls the <code>d_</code> functions, for those terms for which
they are initialized.</li>
<li>It iterates through the proposed toggles.
<ol style="list-style-type: decimal">
<li>It calls the <code>c_</code> functions.</li>
<li>It adds its output to the cumulative change.</li>
<li>It calls the <code>u_</code> functions with the toggle (if more to
come).</li>
<li>It makes the toggle provisionally (if more to come).</li>
</ol></li>
<li>It undoes the provisional toggles.</li>
</ol></li>
<li>If the proposal is accepted, <code>u_</code> function is called, and
network is updated for each toggle.</li>
</ol></li>
<li><code>ModelDestroy()</code> is called:
<ol style="list-style-type: decimal">
<li><code>DestroyStats()</code> is called, iterating through the terms.
<ol style="list-style-type: decimal">
<li>Finalizer (<code>f_</code>) function is called, if defined.</li>
<li>If <code>mtp-&gt;storage</code> is not <code>NULL</code>, it is
freed.</li>
</ol></li>
<li>Other parts of the model are freed; in particular those of
<code>mtp-&gt;aux_storage</code> if not <code>NULL</code>.</li>
</ol></li>
<li><code>ErgmStateRSave()</code> is called:
<ol style="list-style-type: decimal">
<li><code>Network2Redgelist()</code> is called, returning a
<code>SEXP</code> with the state.</li>
<li>For each term, a writer (<code>w_</code> function) is called if
defined, returning a <code>SEXP</code> with the extended state.</li>
<li>These are stored in a vector <code>state$ext.state</code>. Element
<code>state$ext.flag</code> is set to signal that a change was made on
the <code>C</code> side.</li>
</ol></li>
<li><code>NetworkDestroy()</code> is called.</li>
<li>States and other outputs are passed back to <code>R</code>.</li>
<li><code>update.ergm_state()</code> is called.
<ol style="list-style-type: decimal">
<li>It iterates through the formula terms, calling
<code>term$ext.decode()</code> (if defined) to update
<code>state$nw0</code> or other aspects of the network.
<code>state$ext.flag</code> is set to reconciled.</li>
</ol></li>
</ol>
</div>
</div>
<div id="formal-api-definition" class="section level1">
<h1>Formal API definition</h1>
<div id="evaluation-api" class="section level2">
<h2>Evaluation API</h2>
<div id="r-side" class="section level3">
<h3><code>R</code> side</h3>
<p>The following is adapted from the header of
<code>R/InitErgmTerm.R</code></p>
<div id="initergmterm.-and-initwtergmterm.-functions" class="section level4">
<h4><code>InitErgmTerm.*</code> and <code>InitWtErgmTerm.*</code>
functions</h4>
<p>The following are the minimal arguments of these functions:</p>
<p><code>function(nw, arglist, ...)</code></p>
<div id="expects" class="section level5">
<h5>Expects</h5>
<p><code>nw</code>: a <code>network</code> object taken from the LHS of
the model formula or the <code>basis=</code> argument (if given); valued
networks are instrumented with <code>%ergmlhs% &quot;response&quot;</code>
information.</p>
<p><code>arglist</code>: a <code>list</code> of arguments passed to the
term call on the formula. If arguments are passed with names, the list
is named. Typically, helper function <code>check.ErgmTerm()</code> is
used to preprocess this list with the equivalent of R’s
<code>match.call()</code>. Notably, thanks to R’s lazy evaluation, it is
possible to obtain the argument expressions without evaluating them by
calling <code>substitute(arglist)</code>. See
<code>InitErgmTerm.:</code> and <code>InitErgmTerm.*</code> in
<code>R/InitErgmTerm.interaction.R</code> for examples.</p>
<p><code>env</code>: an environment, typically of the
<code>formula</code> from which the term was extracted.</p>
<p>Any term options are passed as direct arguments (not
<code>arglist</code>). See <code>options?ergm</code> for details.</p>
</div>
<div id="returns" class="section level5">
<h5>Returns</h5>
<p>Three return types are possible:</p>
<ol style="list-style-type: decimal">
<li><code>NULL</code>, to indicate that this term does not add to the
model. (E.g., <code>nodefactor(&quot;a&quot;, levels=FALSE)</code>.)</li>
<li>An <code>ergm_model</code> object, in which case its terms are
“pasted” into the model. This is useful for some term operators.</li>
<li>A named <code>list</code> defining the properties of the term. The
following names have special meanings; but any other elements can be
included and will be accessible on the <code>C</code> side.</li>
</ol>
<p>In the following, let <span class="math inline">\(p = \dim(\eta) =
\dim(g(y))\)</span>, the dimension of the statistic <span class="math inline">\(g(y)\)</span> being computed and of the canonical
parameter <span class="math inline">\(\eta\)</span>. If the model is
curved, the model parameter vector <span class="math inline">\(\theta\)</span> is first mapped onto <span class="math inline">\(\eta=\eta(\theta)\)</span>; otherwise, <span class="math inline">\(\eta\equiv\theta\)</span>. Let <span class="math inline">\(q=\dim(\theta)\)</span>.</p>
<p><code>name</code> (required): a string containing the term’s
<code>C</code>-side name: <code>ergm</code> will search for
<code>name</code> prepended with <code>&quot;c_&quot;</code> for change
statistics, <code>&quot;d_&quot;</code> for difference, <code>&quot;s_&quot;</code> for
summary, etc.. This is the only required element.</p>
<p><code>coef.names</code>: a character vector of length <span class="math inline">\(p\)</span> of names for the elements of the
canonical statistic of the model (and canonical parameters); can be
absent or zero-length for auxiliaries.</p>
<p><code>inputs</code>: a vector of (double-precision) numeric inputs
that will be made available to the <code>C</code>-side implementation as
a <code>double</code> vector; optionally,<code>inputs</code> may have an
attribute named <code>&quot;ParamsBeforeCov&quot;</code>, which is used primarily
for backwards compatibility, but can also be used to more conveniently
separate, e.g., metadata elements from vertex attribute elements.</p>
<p><code>iinputs</code>: a vector of integer inputs that will be made
available to the <code>C</code>-side implementation as an
<code>int</code> vector; optionally,<code>iinputs</code> may have an
attribute named <code>&quot;ParamsBeforeCov&quot;</code>, which is used primarily
for backwards compatibility, but can also be used to more conveniently
separate, e.g., metadata elements from vertex attribute elements.</p>
<p><code>pkgname</code>: a string containing the name of the
<code>R</code> package containing the <code>C</code> implementation; if
not specified, the package in which the <code>Init*ErgmTerm.*</code>
function was found is assumed.</p>
<p><code>dependence</code>: a logical value indicating whether the
addition of this term to the model induces dyadic-dependence; if all
terms (ignoring auxiliaries) have <code>dependence</code> set to
<code>FALSE</code>, the model is inferred to be dyad-independent; if not
specified, <code>TRUE</code> is assumed.</p>
<p><code>emptynwstats</code>: a numeric vector of length <span class="math inline">\(p\)</span> providing the value of the statistic if
evaluated on an empty network; if not specified or NULL, assumed to be a
vector of zeros. (See <code>InitErgmTerm.degree()</code> in
<code>R/InitEergmTerm.R</code> for an example.)</p>
<p><code>minpar</code> and <code>maxpar</code>: numeric vectors of
length <span class="math inline">\(q\)</span> giving the bounds on the
valid values for the model’s parameters; if not specified,
<code>-Inf</code> and <code>+Inf</code> vectors are assumed.</p>
<p><code>offset</code>: a logical vector of length <span class="math inline">\(q\)</span> that allows the term to mark some of
its own statistics as having fixed parameters.</p>
<p>For curved terms, all of the following must be present except
<code>cov</code>:</p>
<p><code>params</code>: a list whose names correspond to element names
of the curved parameter vector <span class="math inline">\(\theta\)</span>; the items in the list are there
for historical reasons and are ignored.</p>
<p><code>map</code>: a function taking at least two arguments,
<code>x</code> (a numeric <span class="math inline">\(q\)</span>-vector
containing <span class="math inline">\(\theta\)</span>),
<code>n</code><span class="math inline">\(=p\)</span> (the length of the
output) and an optional <code>cov</code> parameter; it is to return a
numeric vector of length <code>n</code> containing <span class="math inline">\(\eta(\theta)\)</span>.</p>
<p><code>gradient</code>: a function taking the same arguments as
<code>map</code> and returning the gradient of <code>map</code> (<span class="math inline">\(\eta&#39;(\theta)\)</span>) as a <span class="math inline">\(q\times p\)</span> numeric matrix.</p>
<p><code>cov</code>: an optional arbitrary data structure that if
present is passed to <code>map</code> and <code>gradient</code>.</p>
</div>
</div>
</div>
<div id="c-side" class="section level3">
<h3><code>C</code> side</h3>
<div id="modelterm-and-wtmodelterm-data-structures" class="section level4">
<h4><code>ModelTerm</code> and <code>WtModelTerm</code> data
structures</h4>
<p>The data structure contains information accessible to the
<code>C</code>-side statistics. Here, <code>outlist</code> refers to the
list returned by the <code>Init*ErgmTerm.*</code> function.</p>
<p>A number of its elements are for internal use and should generally
not be considered a part of the API or accessed by the term (with some
rare exceptions). These include: <code>c_func</code>,
<code>d_func</code>, <code>i_func</code>, <code>u_func</code>,
<code>f_func</code>, <code>s_func</code>, <code>w_func</code>,
<code>x_func</code>, <code>z_func</code>, <code>statspos</code>,
<code>statcache</code>, <code>emptynwstats</code>.</p>
<p>Furthermore, elements <code>aux_storage</code> and
<code>aux_slots</code> should not be accessed directly but only with
helper described in the auxiliary storage API below.</p>
<p>The following elements are a part of the API:</p>
<p><code>double *attrib</code> (<code>INPUT_ATTRIB</code>,
<code>DINPUT_ATTRIB</code>): contents of <code>outlist$inputs</code>,
shifted by <code>ParamsBeforeCov</code> attribute if given. (Rarely
used.)</p>
<p><code>int *iattrib</code> (<code>IINPUT_ATTRIB</code>): contents of
<code>outlist$iinputs</code>, shifted by <code>ParamsBeforeCov</code>
attribute if given. (Rarely used.)</p>
<p><code>int nstats</code> (<code>N_CHANGE_STATS</code>): value of <span class="math inline">\(p\)</span>, the length of the statistic
vector.</p>
<p><code>double *dstats</code> (<code>CHANGE_STAT</code>): a <span class="math inline">\(p\)</span>-vector to be overwritten with statistic
value.</p>
<p><code>int ninputparams</code> (<code>N_INPUT_PARAMS</code>,
<code>N_DINPUT_PARAMS</code>): length of
<code>outlist$inputs</code>.</p>
<p><code>double *inputparams</code>: contents of
<code>outlist$inputs</code>.</p>
<p><code>int niinputparams</code> (<code>N_IINPUT_PARAMS</code>): length
of <code>outlist$iinputs</code>.</p>
<p><code>int *iinputparams</code> (<code>IINPUT_PARAMS</code>): contents
of <code>outlist$iinputs</code>.</p>
<p><code>void *storage</code> (<code>STORAGE</code>): a pointer managed
by the term to its private storage space.</p>
<p><code>unsigned int n_aux</code> (<code>N_AUX</code>): number of
auxiliaries associated with this term; typically the number requested,
plus one if the term is itself an auxiliary.</p>
<p><code>SEXP R</code>: the contents of <code>outlist</code> as an
<code>R</code> expression.</p>
<p><code>SEXP ext_state</code>: Location of the extended state
information for the term. See below.</p>
</div>
<div id="c_-d_-and-s_-functions" class="section level4">
<h4><code>c_</code>, <code>d_</code>, and <code>s_</code> functions</h4>
<p><code>d_</code> functions are the original difference statistics.
<code>c_</code> functions are new, while <code>s_</code> functions have
been around for a long time, but never formally documented.</p>
<p>Change statistic (binary):
<code>void c_&lt;NAME&gt;(Vertex tail, Vertex head, ModelTerm *mtp, Network *nwp, Rboolean edgestate)</code></p>
<p>Change statistic (valued):
<code>void c_&lt;NAME&gt;(Vertex tail, Vertex head, double weight, WtModelTerm *mtp, WtNetwork *nwp, double edgestate)</code></p>
<p>Difference statistic (binary):
<code>void d_&lt;NAME&gt;(Vertex *tails, Vertex *heads, ModelTerm *mtp, Network *nwp)</code></p>
<p>Difference statistic (valued):
<code>void d_&lt;NAME&gt;(Vertex *tails, Vertex *heads, double *weights, WtModelTerm *mtp, WtNetwork *nwp)</code></p>
<p>Summary statistic (binary):
<code>void s_&lt;NAME&gt;(ModelTerm *mtp, Network *nwp)</code></p>
<p>Summary statistic (valued):
<code>void s_&lt;NAME&gt;(WtModelTerm *mtp, WtNetwork *nwp)</code></p>
<div id="expects-1" class="section level5">
<h5>Expects</h5>
<p><strong>Parameters</strong></p>
<p><strong>Note</strong>: In undirected networks, it can be assumed that
<code>tail</code> &lt; <code>head</code> (and similarly with the
multiple toggles). In bipartite networks, <code>tail</code>s are in the
first partition and <code>head</code>s are in the second.</p>
<p><code>Edge ntgoggles</code>: Number of edges to be toggled or
updated.</p>
<p><code>Vertex tail</code>: Tail of (1) dyad to be toggled or
updated.</p>
<p><code>Vertex *tails</code>: An array of tails of the dyads to be
toggled or updated.</p>
<p><code>Vertex head</code>: Head of (1) dyad to be toggled or
updated.</p>
<p><code>Vertex *heads</code>: An array of heads of the dyads to be
toggled or updated.</p>
<p><code>double weight</code>: New weight for (1) dyad.</p>
<p><code>double *weights</code>: An array of new weights for the dyads
to be toggled or updated.</p>
<p><code>ModelTerm *mtp</code>: A pointer to the <code>ModelTerm</code>
data structure. See <code>inst/include/ergm_changestat.h</code> and
<code>inst/include/ergm_wtchangestat.h</code> for details.</p>
<p><code>Network *nwp</code>: A pointer to the <code>Network</code> of
interest before any toggles are applied.</p>
<p><code>Rboolean edgestate</code>: An indicator of whether edge
<code>(tail,head)</code> is in the network <code>nwp</code>
pre-toggle.</p>
<p><code>double edgestate</code>: The weight of dyad
<code>(tail,head)</code> in the network <code>nwp</code> pre-update.</p>
<p><strong>Storage</strong></p>
<p>All functions except for <code>s_</code> expect any storage they need
to be initialized and up to date (consistent with <code>nwp</code>). In
particular, if their statistic requested <span class="math inline">\(k\)</span> auxiliary terms, the <span class="math inline">\(k\)</span> (<code>mtp-&gt;n_aux</code>) elements
of its <code>mtp-&gt;aux_slots</code> vector will be the indexes of
<code>mtp-&gt;aux_storage</code> where they can find the respective
objects.</p>
</div>
<div id="macros" class="section level5">
<h5>Macros</h5>
<p>It is worth noting that macros defined for <code>d_</code> functions
that refer to a specific toggle, such as <code>TAIL</code>,
<code>HEAD</code>, etc. might not be usable in a <code>c_</code>
function, but it’s made up for by <code>c_</code> function’s reduced
need for bookkeeping: <code>tail</code>, <code>head</code>, etc. can be
used directly.</p>
</div>
<div id="side-effects" class="section level5">
<h5>Side-effects</h5>
<p>These functions overwrite <code>mtp-&gt;dstats</code> (often aliased
as <code>CHANGE_STAT</code>) with the following:</p>
<ul>
<li><code>c_</code> and <code>d_</code> functions: change of the value
of the statistic they implement relative to <code>nwp</code> due to the
toggles.</li>
<li><code>s_</code> the value of the statistic it implements.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="storage-api" class="section level2">
<h2>Storage API</h2>
<p>Every <code>ergm</code> term has private storage, found at
<code>void *mtp-&gt;storage</code>, which allows it to store arbitrary
information about the state of the network, as well as precalculated
values of variables, preallocated memory it needs for its calculations,
or any other use. It does so by specifying an updating function (and,
optionally, an initialization and a finalization function). This
updating function is called every time the network is about to change.
The API for these functions is defined below.</p>
<p>Public storage is found at <code>void **mtp-&gt;aux_storage</code>.
Each auxiliary term gets assigned a slot (i.e.,
<code>void *nwp-&gt;mtp-&gt;aux_storage[i]</code>) to manage; its slot
number is the first element of its <code>aux_slots</code> vector, and
terms requesting it are told which slot to look in in a similar fashion.
An auxiliary term that requests other auxiliaries will have its own slot
as the first element of <code>aux_slots</code> and the slots of
auxiliaries it requests as subsequent elements.</p>
<div id="r-side-1" class="section level3">
<h3><code>R</code> side</h3>
<p>A statistic that only references its private storage <em>or</em> is
an auxiliary itself does not need to do anything special on the
<code>R</code> side.</p>
<p>To request an auxiliary, a term’s <code>InitErgmTerm</code> call’s
output list must include an <code>auxiliaries</code> element containing
a one-sided <code>ergm</code>-style formula listing the auxiliary terms
it wishes to use separated by the <code>+</code> operator.</p>
</div>
<div id="c-side-modifying-storage" class="section level3">
<h3><code>C</code> side: Modifying Storage</h3>
<div id="i_-functions-initializerconstructor" class="section level4">
<h4><code>i_</code> functions: Initializer/Constructor</h4>
<p>This function is optional for using storage: if it’s not provided,
the model code will call the <code>u_</code> function with an invalid
toggle first, signaling for it to initialize.</p>
<p>Binary:
<code>void i_&lt;NAME&gt;(Model *mtp, Network *nwp)</code></p>
<p>Valued:
<code>void i_&lt;NAME&gt;(WtModel *mtp, WtNetwork *nwp)</code></p>
<div id="expects-2" class="section level5">
<h5>Expects</h5>
<p>In general, <code>i_</code> function expects to be called after
<code>ModelInitialize()</code> and <code>NetworkInitialize()</code>,
before any <code>c_</code> or <code>d_</code> functions. That is, the
network must be populated with the ties of its initial state and have
<code>mtp-&gt;aux_storage</code> vector allocated.</p>
<p><strong>Private storage</strong></p>
<p>Network populated with initial ties and initialized model.</p>
<p><strong>Public storage</strong></p>
<p>The first element of <code>mtp-&gt;aux_slots</code> is the index of
the element of <code>mtp-&gt;aux_storage</code> to be managed by this
auxiliary. That is
<code>mtp-&gt;aux_storage[mtp-&gt;aux_slots[0]]</code> is a
<code>void *</code> to point to the data to be public.</p>
<p>The other data passed from the <code>InitErgmTerm.</code> are shifted
over to make room for it.</p>
</div>
<div id="side-effects-1" class="section level5">
<h5>Side-effects</h5>
<p><strong>Private storage</strong></p>
<p>Allocates memory for the information to be stored and overwrites
<code>mtp-&gt;storage</code> with a pointer to it, then updates the
stored information to be consistent with <code>*nwp</code>.</p>
<p><strong>Public storage</strong></p>
<p>Allocates memory for the information to be stored and overwrites
<code>mtp-&gt;aux_storage[mtp-&gt;aux_slots[0]]</code> with a pointer to
it, then updates the stored information to be consistent with
<code>*nwp</code>.</p>
<p>An auxiliary can also use its private storage as needed.</p>
</div>
</div>
<div id="u_-functions-updater" class="section level4">
<h4><code>u_</code> functions: Updater</h4>
<p>Binary:
<code>void u_&lt;NAME&gt;(Vertex tail, Vertex head, Model *mtp, Network *nwp, Rboolean edgestate)</code></p>
<p>Valued:
<code>void u_&lt;NAME&gt;(Vertex tail, Vertex head, double weight, Model *mtp, Network *nwp, double edgestate)</code></p>
<div id="expects-3" class="section level5">
<h5>Expects</h5>
<p>Initialized network. If no <code>i_</code> function was provided, to
be called with a <span class="math inline">\((0,0)\)</span> toggle as a
signal to initialize; otherwise, initialized storage. Any statistic or
auxiliary can rely on its auxiliaries having been initialized before
it.</p>
</div>
<div id="side-effects-2" class="section level5">
<h5>Side-effects</h5>
<p>If called with an a toggle <code>(0,0)</code> and uninitialized
storage, initialize. This will never be done if an <code>i_</code>
function is defined for the term.</p>
<p>Update the state of its storage (<code>mtp-&gt;storage</code> and/or
<code>mtp-&gt;aux_storage[mtp-&gt;aux_slots[0]]</code>) to match what
the state of <code>*nwp</code> would be after the given dyad had been
toggled.</p>
</div>
</div>
<div id="f_-functions-finalizerdestructor" class="section level4">
<h4><code>f_</code> functions: Finalizer/Destructor</h4>
<p>This function is optional for using storage: if it’s not provided,
the model code will free any pointers to
<code>mtp-&gt;aux_storage</code> and <code>mtp-&gt;storage</code> that
are not <code>NULL</code>.</p>
<p>Binary:
<code>void f_&lt;NAME&gt;(Model *mtp, Network *nwp)</code></p>
<p>Valued:
<code>void f_&lt;NAME&gt;(WtModel *mtp, WtNetwork *nwp)</code></p>
<div id="expects-4" class="section level5">
<h5>Expects</h5>
<p>Network and a model.</p>
</div>
<div id="side-effects-3" class="section level5">
<h5>Side-effects</h5>
<p>Deallocates its storage (<code>mtp-&gt;storage</code> and/or
<code>mtp-&gt;aux_storage[mtp-&gt;aux_slots[0]]</code>) and sets its
pointers to <code>NULL</code>.</p>
</div>
</div>
</div>
<div id="c-side-accessing-storage" class="section level3">
<h3><code>C</code> side: Accessing Storage</h3>
<div id="private-storage" class="section level4">
<h4>Private storage</h4>
<p><code>c_</code>, <code>d_</code>, and <code>s_</code> functions can
read from, but not write to, their private storage. <code>c_</code> and
<code>d_</code> functions can rely on initialization having been called
before.</p>
</div>
<div id="public-storage" class="section level4">
<h4>Public storage</h4>
<p>Auxilaries must not implement <code>c_</code>, <code>d_</code>, and
<code>s_</code> functions.</p>
<p>Terms requesting one or more auxiliaries will be passed the indices
of the element of <code>mtp-&gt;aux_storage</code> by inserting them at
the start of <code>mtp-&gt;aux_slots</code>. That is
<code>mtp-&gt;aux_storage[mtp-&gt;aux_slots[0]]</code> is a
<code>void *</code> to point to the data public by the first auxiliary
term on the <code>auxiliaries</code> formula,
<code>mtp-&gt;aux_storage[mtp-&gt;aux_slots[1]]</code> is the second,
etc..</p>
</div>
</div>
</div>
<div id="x_-functions-extensions" class="section level2">
<h2><code>x_</code> functions: eXtensions</h2>
<p>This interface is intended to be used by packages extending
<code>ergm</code> to send arbitrary signals to statistics and
auxiliaries. For example, for temporal ERGMs, it may be used to signal
to the statistic that the clock is about to advance. It is the
responsibility of the extension writer to ensure that everything behaves
sensibly.</p>
<p>Binary:
<code>void x_&lt;NAME&gt;(unsigned int type, void *data, Model *mtp, Network *nwp)</code></p>
<p>Valued:
<code>void x_&lt;NAME&gt;(unsigned int type, void *data, Model *mtp, Network *nwp)</code></p>
<div id="expects-5" class="section level5">
<h5>Expects</h5>
<p><strong>Parameters</strong></p>
<p><code>type</code>: a magic constant identifying the type of signal
being sent. Based on it, the function can ignore the signal, or
determine how to interpret <code>data</code>.</p>
<p><code>data</code>: arbitrary data to be sent to the function; it is
up to the extension writer to determine how it is formatted and
interpreted.</p>
</div>
<div id="side-effects-4" class="section level5">
<h5>Side-effects</h5>
<p>There are no restrictions on side-effects. It is up to the extension
writer to ensure that everything works.</p>
</div>
</div>
</div>
<div id="macros-1" class="section level1">
<h1>Macros</h1>
<p>The following helper macros have been defined to date, and can be
found in <code>storage.h</code>.</p>
<div id="memory-management" class="section level2">
<h2>Memory management</h2>
<p>These functions are defined in <code>ergm_storage.h</code> and
exported.</p>
<p><code>ALLOC_STORAGE(nmemb, stored_type, store_into)</code>: Allocate
a vector of <code>nmemb</code> elements of type
<code>stored_type</code>, save its pointer to private storage and also
to a <code>stored_type *store_into</code> which is also declared. Should
be used by the <code>i_</code> function, but may also be used by the
<code>u_</code> function.</p>
<p><code>GET_STORAGE(stored_type, store_into)</code>: Declare
<code>stored_type *store_into</code> and assign the pointer to private
storage to it. Can be used by all functions.</p>
<p><code>ALLOC_AUX_STORAGE(nmemb, stored_type, store_into)</code>:
Allocate a vector of <code>nmemb</code> elements of type
<code>stored_type</code>, and save it to the auxiliary storage slot
belonging to the calling auxiliary and into a
<code>stored_type *store_into</code> which is also declared. Can be used
by the <code>i_</code> function, but may also be used by the
<code>u_</code> function.</p>
<p><code>GET_AUX_STORAGE(stored_type, store_into)</code>: Declare
<code>stored_type *store_into</code> and assign the pointer to the
auxiliary storage (either for a statistic or for the auxiliary). Can bn
used by all functions.</p>
<p><code>GET_AUX_STORAGE_NUM(stored_type, store_into, ind)</code>:
Declare <code>stored_type *store_into</code> and assign the pointer to
the <code>ind</code>th auxiliary). Can be used by clients of
auxiliaries.</p>
</div>
<div id="miscellaneous-helpers" class="section level2">
<h2>Miscellaneous helpers</h2>
<p><code>ALLOC_AUX_SOCIOMATRIX(stored_type, store_into)</code>: Allocate
an array of appropriate dimension with elements of type
<code>stored_type</code>, save it to auxiliary storage, and into
<code>**store_type</code>, so that <code>store_into[i][j]</code> returns
the value associated with dyad <span class="math inline">\((i,j)\)</span>, with vertices indexed from 1. For
bipartite and undirected networks, as little space as possible (resp. a
rectangle or a triangle) is allocated.</p>
<p>Note that this term assumes that the private and the public storage
of the calling term are not used in any other way.</p>
<p><code>FREE_AUX_SOCIOMATRIX</code>: Frees the sociomatrix allocated by
<code>ALLOC_AUX_SOCIOMATRIX</code>.</p>
</div>
</div>
<div id="mhproposal-storage-api" class="section level1">
<h1>MHproposal storage API</h1>
<div id="auxiliaries" class="section level2">
<h2>Auxiliaries</h2>
<p>MHproposals may also request auxiliary terms. An
<code>InitErgmProposal.&lt;NAME&gt;()</code> or
<code>InitWtErgmProposal.&lt;NAME&gt;()</code>with an
<code>auxiliaries</code> formula will similarly receive the positions of
its auxiliaries’ slots in the network. However, this appears to have a
slight cost in speed and a potentially significant cost in memory, since
the auxiliary may need to duplicate the information in the
<code>MH_</code> function.</p>
</div>
<div id="private-storage-1" class="section level2">
<h2>Private storage</h2>
<p>Functions prefixed with <code>Mi_</code>, <code>Mu_</code>, and,
<code>Mf_</code> serve as respectively the initializers, the updaters,
and the finalizers of the MHproposal storage, though the old-style call
with <code>MHp-&gt;ntoggles==0</code> is also supported. Macros in the
<code>ergm_MHstorage.h</code> header file can be used to access storage
the same way as for the statistics.</p>
<p>The function called to generate the proposal can have a prefix of
either <code>MH_</code> (for backwards compatibility) or
<code>Mp_</code> for consistency.</p>
<p>One important difference is that <code>Mp_</code> function
<em>is</em> permitted to write to its private storage. This may be
useful if, say, a systematic sample is desired.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
